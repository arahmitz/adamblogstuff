[{"content":"","date":"13 May 2025","externalUrl":null,"permalink":"/tags/blender/","section":"Tags","summary":"","title":"Blender","type":"tags"},{"content":" 0. Why wasn\u0026rsquo;t I posting for some time # It\u0026rsquo;s been almost a year since the last post. It was actually a super busy time as we were closing on two very important milestones - first we released a co-op mode of Forever Skies on 9th of December - it was a culmination of my work on the game, as my project-long task was creating TPP animations to match them to FPP ones. It was the last patch before the release, so after a quick Xmas - New Year break we were back working on the final release that happened on April the 14th!\nDue to the workload I had to actually drop side projects such as this page. After a break, as we\u0026rsquo;re working on the Post-Launch Support, I finally found both time \u0026amp; motivation to start working on some small stuff and as I\u0026rsquo;ve been moving towards my goal of becoming a much more technical animator. It seems like there isn\u0026rsquo;t a better post to start on than by doing some python scripting. Before Idive into how I\u0026rsquo;ve written a script that creates a game-ready skeleton hierarchy out of the bones, I wanted to talk why I\u0026rsquo;ve chosen the topic.\nThere are actually two different reasons on why I\u0026rsquo;ve started thinking about this type of tool - first one is that I finally found time to start reading Technical Animation in Video Games by Matt Lake (that needs it\u0026rsquo;s own post when I finally finish it) that talks a lot about automation in the rigging department. The other one is a task I was given that I couldn\u0026rsquo;t finish in time - as I felt defeated, the task lived rent-free in my mind, so I\u0026rsquo;ve decided to tackle it during a weekend and I\u0026rsquo;ve found out that it isn\u0026rsquo;t that complex! That spark inspired me to start a new Markdown file and write a post to share the knowledge I had acquired! Of course I am not a professional programmer, so I am going to explain stuff as someone who is learning python \u0026amp; programming.\nLet\u0026rsquo;s go!\n1. Foreword # In this article you\u0026rsquo;ll learn:\nHow does a game ready skeleton hierarchy look like How to write a simple script to operate on bones in blender How to write a script that builds a game-ready skeleton hierarchy using Python 2. Quick reminder on Skeletal Mesh \u0026amp; Hierarchy # What is a skeletal mesh? # As game animators, we work with Skeletal Meshes everyday. In engine, a skeletal mesh (SK_), is an object that holds information about a 3D model with a skeleton that is skinned. It consists of two main parts:\nMesh - is the visible geometry of the character or object Skeleton - is a hierarchical set of bones that control how the mesh moves and deforms during animation (hence why the mesh is \u0026ldquo;skinned\u0026rdquo; to the skeleton) Unreal Engine\u0026rsquo;s Manny with both skin and skeleton shown SKs are used for anything that requires complex movement or deformation such as characters, creatures and sometimes machinery. In Unreal Engine they\u0026rsquo;re utilized in Animation Sequences (imported animations), Animation Montages and Animation Blueprints.\nIf you ever exported a character from blender or Maya, you might recognize that you only export the bones usually called SKL_ (skeleton_) or JNT_ (joint_) usually used in Maya or def_ (deform_) used in blender by selecting both the skeleton and the mesh of the character. It is the basic building element of a character\u0026rsquo;s rig, on top of which we build the controls.\nHierachy is engine dependant - from this point on, I am going to use a hierarchy that is a standard for Unreal Engine, while it is probably the same or similar in other engines, refer to the documentation! Game-Ready Skeletal Hierarchy # A standard skeletal hierarchy starts with the root bone, that is going to hold information on the main bone of the skeleton - the hips.\nAfter that, the biggest building block of a character is it\u0026rsquo;s spine. UE4\u0026rsquo;s Manny uses 3 bones to hold the information about game character\u0026rsquo;s spine and it\u0026rsquo;s of course a child of hips. As spine03 is usually around character chest, it becomes a parent of the neck and head bones.\nFrom the chest, we of course have arm bones. They have to be attached to chest, so naturally we are going to parent them to spine03. To give animators a good control of the arm, we\u0026rsquo;re going to start with the clavicle that is going to act similar to a collar bone.\nOne of the most important parts to remember is that arms (and legs) are actually mirrored on the side, so we have to actually use a prefix or suffix to differentiate them. I am going to use a _l or _r suffix.\nIn UE we mostly use 3 bones for each finger, making our hierarchy look like this:\nroot hips spine01 spine02 spine03 neck head clavicle_l arm_l forearm_l hand_l pinky01l pinky02l pinky03_l ring01_l ring02_l ring03_l index01_l index02_l index03_l point01_l point02_l point03_l thumb01_l thumb02_l thumb03_l clavicle_r arm_r forearm_r hand_r pinky01_r pinky02_r pinky03_r ring01_r ring02_r ring03_r index01_r index02_r index03_r point01_r point02_r point03_r thumb01_r thumb02_r thumb03_r thigh_l calf_l foot_l balll_l thigh_r calf_r foot_r ball_r I\u0026rsquo;m going to use that as basis for the today\u0026rsquo;s topic.\n3. How do you actually parent bones with script in blender? # Assumptions # For starter\u0026rsquo;s I am going to assume you know how to create a simple armature in blender and you\u0026rsquo;re comfortable with blender UI. You also have knowledge of basic scripting using blender logic. To write scripts there are many different tools - from the in-blender Text editor, to full Python IDE.\nUnderstanding the task # There\u0026rsquo;s an armature with hierarchy:\nbone1 bone2 bone3 To write the script, I first had to understand what exactly I am going to achieve. If I was doing it by hand, I\u0026rsquo;d start by doing this:\nSelect the Armature in viewport and switch to Edit Mode Select bone2, then bone1, CTRL+P -\u0026gt; select Keep Offset Select bone3 then bone 2 and repeat This is basically the list of operations I want to achieve by code.\nTo actually automate this process, let\u0026rsquo;s create a new function called simple_bone_parenting, and tackle issues step by step.\nSelecting the armature and switching to edit mode # The first problem I\u0026rsquo;ve had to tackle is actually going to switch Armature to EDIT MODE, as that\u0026rsquo;s the only mode where you can manipulate bone hierarchy.\ndef simple_bone_parenting(): # grabs the context of a selected object armature = bpy.context.view_layer.objects.active if armature and armature.type == \u0026#39;ARMATURE\u0026#39;: bpy.ops.object.mode_set(mode=\u0026#39;EDIT\u0026#39;) There isn\u0026rsquo;t much to explain; I\u0026rsquo;ve used blender python API docs to store the selection in armature, then switched it to Edit Mode after checking if it exists and if it\u0026rsquo;s an armature.\nSelecting bones and making them a list # The next part is creating a simple parenting method using if statements. That was my first idea on how to tell python what kind of hirarchy I want. After all, every child in hierarchy can only have one parent, so the if statement shouldn\u0026rsquo;t be that scary, right?\ndef simple_bone_parenting(): armature = bpy.context.view_layer.objects.active if armature and armature.type == \u0026#39;ARMATURE\u0026#39;: bpy.ops.object.mode_set(mode=\u0026#39;EDIT\u0026#39;) # create a list of selected bones bones = armature.data.edit_bones for bone in bones: # ensure the name matches the string bone_name = bone.name.lower() if bone_name == \u0026#34;bone1\u0026#34;: # bone1 is the root bone.parent = None elif bone_name == \u0026#34;bone2\u0026#34;: bone.parent = bones[\u0026#34;bone1\u0026#34;] elif bone_name == \u0026#34;bone3\u0026#34;: bone.parent = bones[\u0026#34;bone2\u0026#34;] I\u0026rsquo;ve created a list called bones which hold values of selection, in this case bones = [\u0026quot;bone1\u0026quot;, \u0026quot;bone2\u0026quot;, \u0026quot;bone3\u0026quot;] Next, to ensure that the bones are named properly I\u0026rsquo;ve changed them to lowercase, and created a simple if statements.\nThere are two interesting things:\nFirst of all, bone1 has a parent of None as it\u0026rsquo;s the root of the Armature. Rest of the parents follow an idea that looks exactly like the manual method -\u0026gt; pick a bone (eg. bone1), use function bone.parent, select parent bone from the list (eg. bones[\u0026quot;bone1\u0026quot;]) - that\u0026rsquo;s probably the same thing that is happening \u0026ldquo;under the hood\u0026rdquo; of the hotkeys. To see the change in the Outliner, you actually have to go back to Object Mode - something, I\u0026rsquo;ll have to add later to the script. With that, I\u0026rsquo;ve actually managed to write a script that can easily create a simple bone hierarchy that I\u0026rsquo;ve predefined. That\u0026rsquo;s the a-ha moment I was talking before - the one that made me realise I can write this automatic bone hierarchy script.\n4. Building game-ready skeletal hierarchy with a script # Building MVP # As this is still new territory for me, I\u0026rsquo;ve decided to build the script from the MVP (minimal viable product) and then scale it up, so I\u0026rsquo;ve created a simple, one side bone hierarchy like this:\nhips spine1 spine2 spine3 neck head clavicle arm forearm wrist thigh calf foot ball As there\u0026rsquo;s basically no difference to the previous script, I\u0026rsquo;ve created a new function called create_skeletal_hierarchy() and updated the ifs:\nimport bpy def create_skeletal_hierarchy(): armature = bpy.context.view_layer.objects.active if armature and armature.type == \u0026#39;ARMATURE\u0026#39;: bpy.ops.object.mode_set(mode=\u0026#39;EDIT\u0026#39;) bones = armature.data.edit_bones for bone in bones: bone_name = bone.name.lower() # create spine if bone_name == \u0026#34;hips\u0026#34;: bone.parent = None elif bone_name == \u0026#34;spine1\u0026#34;: bone.parent = bones[\u0026#34;hips\u0026#34;] elif bone_name == \u0026#34;spine2\u0026#34;: bone.parent = bones[\u0026#34;spine1\u0026#34;] elif bone_name == \u0026#34;spine3\u0026#34;: bone.parent = bones[\u0026#34;spine2\u0026#34;] elif bone_name == \u0026#34;neck\u0026#34;: bone.parent = bones[\u0026#34;spine3\u0026#34;] elif bone_name == \u0026#34;head\u0026#34;: bone.parent = bones[\u0026#34;neck\u0026#34;] # create arm chain elif bone_name == \u0026#34;clavicle\u0026#34;: bone.parent = bones[\u0026#34;spine3\u0026#34;] elif bone_name == \u0026#34;arm\u0026#34;: bone.parent = bones[\u0026#34;clavicle\u0026#34;] elif bone_name == \u0026#34;forearm\u0026#34;: bone.parent = bones[\u0026#34;arm\u0026#34;] elif bone_name == \u0026#34;wrist\u0026#34;: bone.parent = bones[\u0026#34;forearm\u0026#34;] # create leg chain elif bone_name == \u0026#34;thigh\u0026#34;: bone.parent = bones[\u0026#34;hips\u0026#34;] elif bone_name == \u0026#34;calf\u0026#34;: bone.parent = bones[\u0026#34;thigh\u0026#34;] elif bone_name == \u0026#34;foot\u0026#34;: bone.parent = bones[\u0026#34;calf\u0026#34;] elif bone_name == \u0026#34;ball\u0026#34;: bone.parent = bones[\u0026#34;foot\u0026#34;] # automatically reset to Object, to see changes in outliner bpy.ops.object.mode_set(mode=\u0026#39;OBJECT\u0026#39;) create_skeletal_hierarchy() There are a few notes - first of all this looks super ugly. My first though was to use a switchcase (I\u0026rsquo;ve had most of my programming knowledge in C after all), but I\u0026rsquo;ve learned that Python didn\u0026rsquo;t have a swithcase implemented until PEP06341! That was actually shocking, as I\u0026rsquo;ve always though of Python as this high-level, easy-to-read, beginner-friendly programming langauge. Said change implemented a match-case that works similarly, but as I\u0026rsquo;ve started an internet sleuth to find another resolution to this case, I\u0026rsquo;ve found something better, that I am going to explore next.\nBesides the obvious, I\u0026rsquo;ve also added a mode_set, to see the differences in Outliner right away.\nIf you run this script, the Armature hierarchy is going to look like this:\nhips spine1 spine2 spine3 neck head clavicle arm forearm wrist thigh calf foot ball At this point I knew, I can actually make it work pretty well.\nDictionary for the rescue! # As I was looking through the web, I\u0026rsquo;ve also sent a question to my friend, who\u0026rsquo;s actually a programmer, if there are any tricks to make this prettier than this myriad of ifs, as for now there are 14 different if statements and if the skeleton was mirrored, it\u0026rsquo;d be 22!\nWhy dont you use dictionary?\nThat was basically the first answer I\u0026rsquo;ve got. I haven\u0026rsquo;t used dictionaries before, so I went straight to documentation, to understand what it is and how can it help me. Let\u0026rsquo;s start by saying, that the dictionary is a simple data structure, an array basically, that instead of being indexed by range of numbers, are indexed by keys.\nIn my understanding for this case, dictionary is basically an array, where I can store an unique key:value pair, which looks suspiciously close to our ifs.\nMe realizing that my if is basically a key and a value So how does it work?\nLet\u0026rsquo;s define a dictionary called my_dictionary, that is going to hold three pairs of data:\nblender is a dcc unrealengine is an engine python is a langauge my_dictionary = { \u0026#34;blender\u0026#34;: \u0026#34;dcc\u0026#34;, \u0026#34;unrealengine\u0026#34;: \u0026#34;engine\u0026#34;, \u0026#34;python\u0026#34;: \u0026#34;langauge\u0026#34; } Now, we can print, a simple sentence, using it:\nprint(f\u0026#34;\u0026#34;\u0026#34;I use blender as my {my_dictionary[\u0026#39;blender\u0026#39;]}, Unreal Engine as my {my_dictionary[\u0026#39;unrealengine\u0026#39;]}, and python as my programming {my_dictionary[\u0026#39;python\u0026#39;]}\u0026#34;\u0026#34;\u0026#34;) Outputs: \u0026ldquo;I use blender as my dcc, Unreal Engine as my engine and python as my programming langauge\u0026rdquo;.\nit\u0026rsquo;s important in order to use dictionary with a string, they need to be quoted, otherwise it\u0026rsquo;s going to throw an undefined error.\nBuilding a hierarchy dictionary # Now that we have a specific tool to build a hierarchy on, let\u0026rsquo;s update the code to use the proper hierarchy:\n# child : parent skeletal_hierarchy = { \u0026#34;hips\u0026#34;: None, # \u0026#34;root\u0026#34; \u0026#34;spine1\u0026#34;: \u0026#34;hips\u0026#34;, \u0026#34;spine2\u0026#34;: \u0026#34;spine1\u0026#34;, \u0026#34;spine3\u0026#34;: \u0026#34;spine2\u0026#34;, \u0026#34;neck\u0026#34;: \u0026#34;spine3\u0026#34;, \u0026#34;head\u0026#34;: \u0026#34;neck\u0026#34;, \u0026#34;clavicle\u0026#34;: \u0026#34;spine3\u0026#34;, \u0026#34;arm\u0026#34;: \u0026#34;clavicle\u0026#34;, \u0026#34;forearm\u0026#34;: \u0026#34;arm\u0026#34;, \u0026#34;wrist\u0026#34;: \u0026#34;forearm\u0026#34;, \u0026#34;thigh\u0026#34;: \u0026#34;hips\u0026#34;, \u0026#34;calf\u0026#34;: \u0026#34;thigh\u0026#34;, \u0026#34;foot\u0026#34;: \u0026#34;calf\u0026#34;, \u0026#34;ball\u0026#34;: \u0026#34;foot\u0026#34;, } Note - it follows the idea that child is on the left and parent on the right, where hips, as the root bone has value of None.\nAs the dictionary is ready, the next step is updating the function to use it instead of the if-ology.\nimport bpy def create_skeletal_hierarchy(): armature = bpy.context.view_layer.objects.active if armature and armature.type == \u0026#39;ARMATURE\u0026#39;: bpy.ops.object.mode_set(mode=\u0026#39;EDIT\u0026#39;) bones = armature.data.edit_bones # child : parent skeletal_hierarchy = { \u0026#34;hips\u0026#34;: None, # \u0026#34;root\u0026#34; \u0026#34;spine1\u0026#34;: \u0026#34;hips\u0026#34;, \u0026#34;spine2\u0026#34;: \u0026#34;spine1\u0026#34;, \u0026#34;spine3\u0026#34;: \u0026#34;spine2\u0026#34;, \u0026#34;neck\u0026#34;: \u0026#34;spine3\u0026#34;, \u0026#34;head\u0026#34;: \u0026#34;neck\u0026#34;, \u0026#34;clavicle\u0026#34;: \u0026#34;spine3\u0026#34;, \u0026#34;arm\u0026#34;: \u0026#34;clavicle\u0026#34;, \u0026#34;forearm\u0026#34;: \u0026#34;arm\u0026#34;, \u0026#34;wrist\u0026#34;: \u0026#34;forearm\u0026#34;, \u0026#34;thigh\u0026#34;: \u0026#34;hips\u0026#34;, \u0026#34;calf\u0026#34;: \u0026#34;thigh\u0026#34;, \u0026#34;foot\u0026#34;: \u0026#34;calf\u0026#34;, \u0026#34;ball\u0026#34;: \u0026#34;foot\u0026#34;, } for bone in bones: bone_name = bone.name.lower() # a way to add go through all bones # and assign them parents # based on their dictionary value # automatically reset to Object, to see changes in outliner bpy.ops.object.mode_set(mode=\u0026#39;OBJECT\u0026#39;) create_skeletal_hierarchy() Assigning bone parents using dictionary # As I\u0026rsquo;ve deleted the big if-ology, the next part is actually finding a way to actually attach the bones correctly. To do that, I\u0026rsquo;ve utilized the loop that was there used before:\nfor bone in bones: bone_name = bone.name.lower() bone_name exists to match the values of the dictionary even if the bone is going to be capitalized, so I can easily look if it exists in skeletal_hierarchy. If it does, I can find it\u0026rsquo;s parent as a key:value.\nfor bone in bones: bone_name = bone.name.lower() for bone_name in skeletal_hierarchy: # note it uses [bone_name] without \u0026#34;\u0026#34;, # because it\u0026#39;s a value that holds a string, not string itself! parent = skeletal_hierarchy[bone_name] Now, the only thing that I need is to assign every child a parent. As I\u0026rsquo;m checking if the bone exists in the hierarchy, I can utilize that point to use bone.parent.\nfor bone in bones: bone_name = bone.name.lower() for bone_name in skeletal_hierarchy: parent = skeletal_hierarchy[bone_name] # checking if parent exists # checking if parent exists in hierarchy definition if parent and parent in skeletal_hierarchy: # we\u0026#39;re parentng to our actual bones list bone.parent = bones[parent] After the addition of this part, the script looks like this:\nimport bpy def create_skeletal_hierarchy(): armature = bpy.context.view_layer.objects.active if armature and armature.type == \u0026#39;ARMATURE\u0026#39;: bpy.ops.object.mode_set(mode=\u0026#39;EDIT\u0026#39;) bones = armature.data.edit_bones skeletal_hierarchy = { \u0026#34;hips\u0026#34;: None, # \u0026#34;root\u0026#34; \u0026#34;spine1\u0026#34;: \u0026#34;hips\u0026#34;, \u0026#34;spine2\u0026#34;: \u0026#34;spine1\u0026#34;, \u0026#34;spine3\u0026#34;: \u0026#34;spine2\u0026#34;, \u0026#34;neck\u0026#34;: \u0026#34;spine3\u0026#34;, \u0026#34;head\u0026#34;: \u0026#34;neck\u0026#34;, \u0026#34;clavicle\u0026#34;: \u0026#34;spine3\u0026#34;, \u0026#34;arm\u0026#34;: \u0026#34;clavicle\u0026#34;, \u0026#34;forearm\u0026#34;: \u0026#34;arm\u0026#34;, \u0026#34;wrist\u0026#34;: \u0026#34;forearm\u0026#34;, \u0026#34;thigh\u0026#34;: \u0026#34;hips\u0026#34;, \u0026#34;calf\u0026#34;: \u0026#34;thigh\u0026#34;, \u0026#34;foot\u0026#34;: \u0026#34;calf\u0026#34;, \u0026#34;ball\u0026#34;: \u0026#34;foot\u0026#34;, } for bone in bones: bone_name = bone.name.lower() if bone_name in skeletal_hierarchy: parent = skeletal_hierarchy[bone_name] if parent and parent in bones: bone.parent = bones[parent] bpy.ops.object.mode_set(mode=\u0026#39;OBJECT\u0026#39;) create_skeletal_hierarchy() Running the code on full skeleton # This script looks much better, I can quickly change the hierarchy by updating dictionary. Everything went well unless I tried to use it on a new armature definition:\nhips spine1 spine2 spine3 neck head clavicle_l arm_l forearm_l wrist_l thigh_l calf_l foot_l ball_l clavicle_r arm_r forearm_r wrist_r thigh_r calf_r foot_r ball_r If you actually run this script, the hierarchy is going to look like this:\nhips spine1 spine2 spine3 neck head clavicle_l arm_l forearm_l wrist_l thigh_l calf_l foot_l ball_l clavicle_r arm_r forearm_r wrist_r thigh_r calf_r foot_r ball_r Why is that?\nLet\u0026rsquo;s break down what is actually happening when the script goes through loops for two bones: spine3 and clavicle_l\nFor the spine3:\nfor bone in bones: # checks if spine3 exists in bones -\u0026gt; spine3 does # looks up the name and change spine3 to all lower case # -\u0026gt; name changes to spine3 bone_name = bone.name.lower() # checks if spine3 exists in skeletal_hierarchy -\u0026gt; it does if bone_name in skeletal_hierarchy: # parent becomes the value of key spine3, # which is \u0026#34;spine3\u0026#34;:\u0026#34;spine2\u0026#34; -\u0026gt; parent = spine2 parent = skeletal_hierarchy[bone_name] # checks if parent exists -\u0026gt; spine2 does # checks if parent exists in bones -\u0026gt; spine2 does if parent and parent in bones: # parent the spine3 bone to parent # -\u0026gt; parent spine3 to spine2 bone.parent = bones[parent] It create a nice looking hierarchy, where spine3 is parented to spine2.\nBut when it evaluates clavicle_l, there\u0026rsquo;s actually a bug:\nfor bone in bones: # checks if clavicle_l exists in bones -\u0026gt; it does # looks up the name and change clavicle_l to all lower case # -\u0026gt; name changes to clavicle_l bone_name = bone.name.lower() # checks if clavicle_l exists in skeletal_hierarchy -\u0026gt; it does not if bone_name in skeletal_hierarchy: At this point the rest of the code doesn\u0026rsquo;t matter, it\u0026rsquo;ll bypass it and the same thing will happen to rest of the suffixed bones. That\u0026rsquo;s the reason why final hierarchy do not parent suffixed bones at all.\nReading suffixed bones # I am not going to lie - this part took me the longest to figue out. As a python beginner and someone who\u0026rsquo;s mostly comfortable with C, Python amazes me with so many quality-of-life functions - one of them is flexibility in working with strings.\nLet\u0026rsquo;s break what is the full name of a bone:\ngraph LR; A[clavicle]--\u003eB[_l]; is just\ngraph LR; A[base_name]--\u003eB[suffix]; Of course there are bones without the suffix, their breakdown looks like this:\ngraph LR; A[spine03]--\u003eB[\" \"]; That\u0026rsquo;s important, because Python\u0026rsquo;s implementation of string operations is actually super handy, let\u0026rsquo;s look at this\nbase_name = \u0026#34;clavicle\u0026#34; suffix = \u0026#34;_l\u0026#34; print(base_name + suffix) # clavicle_l This realisation is actually wild. It fixes all the problems, as I can now:\nTake a bone_name Split it to it\u0026rsquo;s base_name and suffix Find parent using base_name Re-attach suffix to parent - IMPORTANT Parent bone_name to parent+suffix Point 4. is crucial - I\u0026rsquo;ve spent a lot of debugging time because I forgot to actually re-attach the suffix.\nNow, to the implementation:\nI\u0026rsquo;ll start with the splitting.\nAS I\u0026rsquo;ve said before - Python implementaion helps a lot with the strings - each string can be used as a list of letters, so I could just check if the string ends with a suffix (thanks to endswith()), and if it did - delete it. I\u0026rsquo;ll be adding clavicle_l and spine3 in comments to explain\nfor bone in bones: name = bone.name.lower() baseName = \u0026#34;\u0026#34; # declaration + resetting it to null suffix = \u0026#34;\u0026#34; # declaration + resetting it to null if name.endswith(\u0026#34;_l\u0026#34;): # clavicle_l - true baseName = name[0:-2] # clavicle suffix = \u0026#34;_l\u0026#34; # _l elif name.endswith(\u0026#34;_r\u0026#34;): # both false baseName = name[0:-2] suffix = \u0026#34;_r\u0026#34; else: # spine3 - true baseName = name[:] # spine3 suffix = \u0026#34;\u0026#34; # \u0026#34;\u0026#34; Now that I have them split, lets find the parent(the key:value) - that\u0026rsquo;s nothing new besides declaring parent_full that we\u0026rsquo;re going to use in the next step\nif base_name in skeletal_hierarchy: # clavicle / spine3 parent_base = skeletal_hierarchy[base_name] # clavicle / spine3 parent_full = \u0026#34;\u0026#34; # declaration + resetting it to null Looking at the list, next one is the most important one - we have to re-attach suffix to the parent, that\u0026rsquo;s why I\u0026rsquo;ve created parent_full.\nThat\u0026rsquo;s a place where I discovered another possible bug - I had my _l or _r bones working, but clavicle_l and leg_l and their _r versions have parents, that have blank suffix, so normally, it would look for spine3_l or hips_l and it doesn\u0026rsquo;t exist, that\u0026rsquo;s why I\u0026rsquo;ve added an elif to check if the non-suffixed version exists in bones.\nif parent_base: if parent_base + suffix in bones: # spine3_l - false, spine2 - true parent_full = parent_base + suffix elif parent_base in bones: # spine3 - true parent_full = parent_base else: parent_full = None To end the script, I have to actually parent the bones to the proper parents:\nif parent_full: # spine3 - true, spine2 - true # parent clavicle_l to spine3, # parent spine3 to spine2 bone.parent = bones[parent_full] Aaaaaand\u0026hellip; eureka! I finally created a script that takes bones and parent them using predefined hierarchy. Of course there are other problems that might be a good excercise to fix:\nwhat if there are more numbers in spine? What if there are prefixes instead of affixes? I might add these cases to my script, but for the demonstration purpose let\u0026rsquo;s say that we have a set way of creating bones in our team \u0026amp; everyone is following the naming conventions.\nReady script # So here it is, a script to build a game-ready skeletal hierarchy\nimport bpy def create_skeletal_hierarchy(): armature = bpy.context.view_layer.objects.active if armature and armature.type == \u0026#39;ARMATURE\u0026#39;: bpy.ops.object.mode_set(mode=\u0026#39;EDIT\u0026#39;) bones = armature.data.edit_bones skeletal_hierarchy = { \u0026#34;hips\u0026#34;: None, # \u0026#34;root\u0026#34; \u0026#34;spine1\u0026#34;: \u0026#34;hips\u0026#34;, \u0026#34;spine2\u0026#34;: \u0026#34;spine1\u0026#34;, \u0026#34;spine3\u0026#34;: \u0026#34;spine2\u0026#34;, \u0026#34;neck\u0026#34;: \u0026#34;spine3\u0026#34;, \u0026#34;head\u0026#34;: \u0026#34;neck\u0026#34;, \u0026#34;clavicle\u0026#34;: \u0026#34;spine3\u0026#34;, \u0026#34;arm\u0026#34;: \u0026#34;clavicle\u0026#34;, \u0026#34;forearm\u0026#34;: \u0026#34;arm\u0026#34;, \u0026#34;wrist\u0026#34;: \u0026#34;forearm\u0026#34;, \u0026#34;thigh\u0026#34;: \u0026#34;hips\u0026#34;, \u0026#34;calf\u0026#34;: \u0026#34;thigh\u0026#34;, \u0026#34;foot\u0026#34;: \u0026#34;calf\u0026#34;, \u0026#34;ball\u0026#34;: \u0026#34;foot\u0026#34;, } for bone in bones: bone_name = bone.name.lower() base_name = \u0026#34;\u0026#34; suffix = \u0026#34;\u0026#34; if bone_name.endswith(\u0026#34;_l\u0026#34;): base_name = bone_name[0:-2] suffix = \u0026#34;_l\u0026#34; elif bone_name.endswith(\u0026#34;_r\u0026#34;): base_name = bone_name[0:-2] suffix = \u0026#34;_r\u0026#34; else: base_name = bone_name[:] suffix = \u0026#34;\u0026#34; if base_name in skeletal_hierarchy: parent_base = skeletal_hierarchy[base_name] parent_full = \u0026#34;\u0026#34; if parent_base: if parent_base + suffix in bones: parent_full = parent_base + suffix elif parent_base in bones: parent_full = parent_base else: parent_full = None if parent_full: bone.parent = bones[parent_full] bpy.ops.object.mode_set(mode=\u0026#39;OBJECT\u0026#39;) create_skeletal_hierarchy() 5. Closing thoughts # It\u0026rsquo;s a great feeling to finally get that break-through, even though it\u0026rsquo;s a bit bitter-sweet feeling, as I\u0026rsquo;ve came up with the resolution a week too late. I feel like I\u0026rsquo;ve actually learned a few new tricks and deepened my python \u0026amp; programming knowledge. That\u0026rsquo;s also a good momentum to work on some new stuff and get even better.\nI hope that my explanation helped you as well, I am open to talking about it and see you in another tech dive!\n","date":"13 May 2025","externalUrl":null,"permalink":"/posts/202505-skeletonhierarchy_blender/","section":"Posts","summary":"","title":"Building a skeleton hierarchy using python","type":"posts"},{"content":"","date":"13 May 2025","externalUrl":null,"permalink":"/tags/intermediate/","section":"Tags","summary":"","title":"Intermediate","type":"tags"},{"content":"","date":"13 May 2025","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"13 May 2025","externalUrl":null,"permalink":"/tags/rigging/","section":"Tags","summary":"","title":"Rigging","type":"tags"},{"content":"","date":"13 May 2025","externalUrl":null,"permalink":"/tags/scripting/","section":"Tags","summary":"","title":"Scripting","type":"tags"},{"content":"","date":"13 May 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"13 May 2025","externalUrl":null,"permalink":"/tags/technical/","section":"Tags","summary":"","title":"Technical","type":"tags"},{"content":" ","date":"13 May 2025","externalUrl":null,"permalink":"/","section":"Welcome to Adam Madej Animations!","summary":"","title":"Welcome to Adam Madej Animations!","type":"page"},{"content":"","date":"17 July 2024","externalUrl":null,"permalink":"/tags/ikfk/","section":"Tags","summary":"","title":"Ikfk","type":"tags"},{"content":" 0. Foreword # In this article you\u0026rsquo;ll learn:\nThe difference between Forward Kinematics (FK) and Inverse Kinematics (IK) How to set up an IKFK switch in blender Creating and using custom properties for seamless IKFK transitions Download the project files here.\n1. Why do we need an IKFK switch? # What do IK and FK mean? # If you\u0026rsquo;re new to the concepts of FK (Forward Kinematics) and IK (Inverse Kinematics), then let\u0026rsquo;s start with a quick overview - these terms relate to how the bone chain behave in animation.\nForward Kinematics # Forward Kinematics Driven Arm Forward Kinematics - FK for short - is a standard bone chain behavior. In an FK setup, each bone in chain follows the transformations of it\u0026rsquo;s parent. For example, let\u0026rsquo;s look at an FK_Arm setup:\narm forearm hand Rotating the arm is also going to rotate the forearm and hand because they are down in the arm\u0026rsquo;s hierarchy. Typically, these chains are controlled by rotation of each bone. Translation might be possible in some setups, but it isn\u0026rsquo;t the standard. Forward Kinematics chain is great for creating smooth, natural arcs in animation, as it requires keyframing each bone individually, it promotes overlapping by offsetting each bone keyframes.\nInverse Kinematics # Inverted Kinematics Driven Arm Inverse KInematics - abbreviated as IK - works in the opposite manner. It makes the end bone of the chain the primary motion driver. In an IK setup, moving the end bone (like hand in our arm chain) influences the positions and rotations of the parent bones (arm and forearm). This allows for both rotation and translation of the end bone, with the parent bone adjusting to maintain the correct position. To help control the rotation and bending direction, IK setups include a pole target, to which the bend \u0026ldquo;points to\u0026rdquo;.\nIK is particularly useful for animating limbs that interact with the environment, such as a foot maintaining the contact with the ground during a walk cycle. The end bone (foot in this case) can be \u0026ldquo;pinned\u0026rdquo; in place, while the rest of the body moves, providing stability and precise control over the limb\u0026rsquo;s position.\n2. How to create an IKFK switch in blender? # Preparation # First, if you havem\u0026rsquo;t already, download the project files.\nThe files are prepared for version 4.0, but should be backwards compatibile with older blender versions. After opening the ikfkswitcher_start.blend file, your screen should look like this: Clean ikfkswitch_start.blend file Close the note by dragging the viewport corner over it, and let\u0026rsquo;s start rigging! Closing the text panel Parenting the FK Skeleton # To start, switch to Pose Mode and make sure the bone names are visible. Select the fk_ bone first, then SHIFT-click to select the corresponding def_ bone. Press SHIFT+CTRL+C to open the Bone Constraints context menu and choose Copy Transform.\nAdding copy transform to fk_upperarm Next, rename the constraint to FK_CopyTransform to keep things organized.\nRenaming the copy transform constraint Repeat this process for the remaining fk_ bones, Once done, your rig should look like this:\nRemember to check if your constraints works properly! Parenting the IK Skeleton # For the IK skeleton, follow the same steps as for the FK skeleton: add a Copy Transform constraint to the ik_ bones and rename the constraints to IK_CopyTransform. Note: There\u0026rsquo;s both ctrl_ik_hand and ik_hand bones. First one is the one you\u0026rsquo;re going to use to move the IK arm. Ensure you constrain def_hand to ik_hand. Adding copy transform constraint for IK bones After adding the IK_CopyTransform constraints, your def_ bones should no longer follow the fk_ bones. Blender\u0026rsquo;s constraint system reads from the bottom up, and checks the first constraint with 100% influence. If IK_CopyTransform is set to 1, it wont read FK_CopyTransform at all. We\u0026rsquo;ll use this blender property for the next step.\nCreating a Custom Property # There are different approaches to where the IKFK property should be located and as a rigger, it\u0026rsquo;s your choice where will you add it. For the simplicity, we\u0026rsquo;ll use the Root bone at the world\u0026rsquo;s origin. To add a property, click on the Root bone and navigate to Bone Properties, then open the Custom Properties menu.\nFinding the Custom Properties menu Click the + NEW button, then use the cog icon to set up the property as follows:\nType: Float (we\u0026rsquo;ll use the value from 0 to 1, allowing for a blend of both IK and FK influences) Property Name: IKFK_Switch Default Value: 1.00 Min and Max: 0.00 and 1.00, respectively Soft Limits: [ ] (not used) Step: 0.10 (changes how much the value incremets with each left or right arrow click) Precision: 3 Subtype: Plain Data Description: \u0026ldquo;Switches from IK to FK constraint\u0026rdquo; (for clarity) Library Overdrive: [x] (check this to ensure properties carry over when referencing rigs to other scenes) Your menu should look like this: Custom property options Adding the Custom Property as a CopyTransform Driver # Next, right-click the property and select Copy as New Driver Custom Property Right Click menu Navigate to the def_ bones and right-click on the IK_CopyTransform influence: Copying the Driver to IK_CopyTransform Influence If the driver window dissapears, don\u0026rsquo;t worry—right-click the influence again and select Edit Driver.\nSet up the driver as follows:\nType: Scripted Expression (we want to use our variable in an expression) Expression: 1-IKFK_Switch The name must match your Custom Property name. This expression ensures that when the IKFK_Switch is set to 0, the def_bone follows the IK skeleton and when set to 1, it follows the FK skeleton. We\u0026rsquo;re substracting because, as mentioned earlier, blender constraints read from bottom to top. If IK_CopyTransform has an influence of 0, blender will automatically use the next \u0026ldquo;full\u0026rdquo; influence constraint, FK_CopyTransform.\nSo, when IKFK_Switch is 1, the expression is 1 - 1 = 0, disabling the IK_CopyTransform. When the IKFK_Switch is 0, the expression is 1 - 0 = 1, enabling IK_CopyTransform and making the IK control the def_ bones.\nIf the rest of the driver setup isn\u0026rsquo;t filled automatically, click Copy Full Path of the Custom Property you\u0026rsquo;ve created and paste it in the driver editor.\nThe finished driver should look like this: Finished IKFK_Switch Driver Now, right-click the newly created driver (indicated by violet color instead of blue) and use Copy Driver to copy it to the rest of def_ bones. Copying the driver to the rest of the def_bones Using the Custom Property # That\u0026rsquo;s all! Now we need to test if everything works properly. Click on Root bone and go to the Transform Tab to see the IKFK_Switch property. IKFK_Switch Property in Transform Tab If it\u0026rsquo;s there and you can move it from 0 to 1, pose both IK and FK bones and try switching between them. If everything was done correctly, the skinned arm should move between the poses you\u0026rsquo;ve created! Always check if systems you\u0026rsquo;ve created work properly BONUS: Hiding unused controls with IKFK Switch # As a bonus, let\u0026rsquo;s add a quick Quality of Life upgrade for our IKFK switch. Typically, with the controls set up as described earlier, you would need to manually show and hide the IK and FK controls. While this is manageable, as riggers we should aim to enhance the user experience. Therefore, we will streamline process by adding a couple of additional drivers.\nFirst, return to the Root bone\u0026rsquo;s properties and again use Copy as New Driver for the IKFK_Switch property. Navigate to the Armature tab, right click the eye icon of the ik bone group, and select Paste Driver. Copying driver to Bone Collection visibility button Next, right-click the visibility button and choose Edit Driver. Set up the driver as follows:\nType: Scripted Expression Expression: 1-IKFK_Switch After setting this up, test to ensure the IK controls dissapear when the IKFK_Switch is set to 1. If the driver is setup correctly, the IK controls shouldn\u0026rsquo;t be visible when IKFK_Switch is set to 1 To apply the same logic to the FK chain, copy the driver from ik bone collection, paste it to the fk bone collection visibility, and change the expression to IKFK_Switch. This ensures that when the property is set to 0 (making the IK chian visible and active), the FK chain is hidden. Remember to change the expression, otherwise both bone groups are going to be visible only on 0 Once the setup is complete, one of the collections should dissapear accordingly. Now, test the rig: if the IKFK_Switch is set to 0, the IK controllers should be visible and active, while the FK controllers should be hidden. Setting the switch to 1 should make the FK controllers visible and the IK controllers hidden. By doing that, animators are going to love you This small addition can save animators a lot of unnecessary clicking, improving their flow and focus on the tasks. Given that this setup is not time-consuming, there\u0026rsquo;s no reason not to add it whenever you\u0026rsquo;re working on any IFK switchable chain.\n3. Closing Thoughts # Congratulations on creating your own IKFK switch in blender! This setup allows to seamlessly switch (and keyframe) between FK and IK, one of the most crucial rig features. Remember to experiment with different setups and refine your rigging techniques to suit animator\u0026rsquo;s needs - because rigs do not live in a vacuum!\nIf you have any questions or run into issues, feel free to contact me. Thanks for following the tutorial and happy rigging!\n","date":"17 July 2024","externalUrl":null,"permalink":"/posts/202407-ikfkswitch_blender/","section":"Posts","summary":"A tutorial on creating IKFK switches in blender without addons or scripting","title":"Simple IKFK Switch in blender","type":"posts"},{"content":"","date":"17 July 2024","externalUrl":null,"permalink":"/tags/tutorial/","section":"Tags","summary":"","title":"Tutorial","type":"tags"},{"content":" Hey! I\u0026rsquo;m Adam. I am an Animator / Rigger, based in Wrocław, Poland.\nCurrently, I am working at Far From Home where I am animating and rigging Forever Skies!\nWelcome to my personal website, where I explore the art of rigging, gameplay animation and technical animation. This blog serves as a blend of insights into rigging techniques, animation insights, scripting, pipelines, workflows and their application in the dynamic world of video games.\nBeyond discussion, my goal is to offer valuable notes, tutorials and resources to aid you on your (and mine) journey through everything there is related to animation for video games. I\u0026rsquo;ll also try to sprinkle in some thought-provoking book reviews and reflections on the broader animation industry. I believe in the power of animation as the ultimate storytelling medium in the entertainment industry. I\u0026rsquo;m excited to share my experiences and perspectives on every facet of this captivating medium.\nMy unique background encompasses both art (Graphic Design) and engineering (Computer Science), a blend that has propelled me into the specialized field of technical animation.\nOutside of my professional pursuits, I\u0026rsquo;m a reportage photographer, crafting digital photography books, a cinematography freak and an avid player of both digital and analog RPGs. I hope you\u0026rsquo;ll enjoy your time here!\nIf you have any questions or just want to chat - I am open to DMs at both my @arahfx and Adam Madej!\nFor business inquires, please use the contact form.\n","date":"12 May 2024","externalUrl":null,"permalink":"/about/","section":"Welcome to Adam Madej Animations!","summary":"","title":"About","type":"page"},{"content":" Let\u0026rsquo;s Create Something Amazing Together! I\u0026rsquo;m always thrilled to connect with other artists, game developers and animation enthusiasts. Whether you have an exciting project in mind, want to discuss the latest trends, games, movies or books or just share your love for the craft - I\u0026rsquo;d love to hear from you!\nFeel free to reach out by dropping me a message using the form below.\nName Email Address Message ","date":"12 May 2024","externalUrl":null,"permalink":"/contact/","section":"Welcome to Adam Madej Animations!","summary":"","title":"Contact","type":"page"},{"content":" If I am keeping a digital notebook - why not share it? This section contains various articles I’ve written, either as a personal wikia entries or as tutorials to assist fellow animators, riggers and techanimators on their own journey through the craft. Additionally, you’ll find different perspectives and insights I’ve decided to share about animation craft in general.\n","date":"12 May 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" Forever Skies (PC, PS5) Forever Skies - Animation \u0026amp; Rigging Forever Skies is a first-person post-apocalyptic survival game. Return to Earth, ravaged by an ecological disaster. Fly, upgrade and customize your mobile high-tech airship base. Scavenge resources to survive, face dangers on the surface and hunt for viral pathogens to cure a mysterious illness.\nIn Forever Skies, I am responsible for animation and rigging within the project. I am focused on the blender-related side of the pipeline where I rig bipeds, non-bipeds, weapons and structures. Additionally I am responsible for many animations within the project - I\u0026rsquo;ve been mostly adapting already-done FPP animations into TPP (for co-op purposes), but I\u0026rsquo;ve also done my share of FPP animation, weapon, structure and non-humanoid sequences both in blender and using UE4\u0026rsquo;s Sequencer.\nBeyond the creative aspects, I actively contribute to integrating animations into Unreal Engine 4, ensuring a seamless and immersive gaming experience. I strive to create a better animation pipeline, actively using python to address and solve various technical challanges, thus optimizing our workflow within the team.\n","date":"12 May 2024","externalUrl":null,"permalink":"/projects/","section":"Welcome to Adam Madej Animations!","summary":"","title":"Projects","type":"page"},{"content":" ","date":"12 May 2024","externalUrl":null,"permalink":"/reel/","section":"Welcome to Adam Madej Animations!","summary":"","title":"Reel","type":"page"},{"content":" Animacyjne Dojo (PL) Presentation available here Animacyjne Dojo is a presentation I gave for Digital Night Studio at Lodz University of Technology, focusing on gameplay animation. It provides an overview of the fundamental principles from a gameplay animator\u0026rsquo;s perspective, addresing daily tasks and unique challanges. The presentation covers essential animation exeercises such as the bouncing ball and tails/squirrel, offering tips and tricks for each. It concludes with resources and guidance for those looking to learn animation and start their careers in the field. (Presentation in Polish)\n","date":"12 May 2024","externalUrl":null,"permalink":"/talks/","section":"Welcome to Adam Madej Animations!","summary":"","title":"Talks","type":"page"},{"content":"","date":"17 March 2024","externalUrl":null,"permalink":"/tags/beginner/","section":"Tags","summary":"","title":"Beginner","type":"tags"},{"content":"","date":"17 March 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" 0. Foreword # In this article you\u0026rsquo;ll learn:\nHow to rig a ball in blender How to create armatures and move them to snap bones in place How to use Bone Widget to create controls How to keep your rig and project file clean Basics of preparing rig for usage by other people 1. Preparation # For our blender ball rig, we\u0026rsquo;re start by downloading the project files and Bone Widget.\nHeads up: As of the publication day, blender doesn\u0026rsquo;t use riging nodes, that\u0026rsquo;s why we\u0026rsquo;ll need to do little hacking in the controllers hierarchy, that I\u0026rsquo;ll try to avoid later in the series, I\u0026rsquo;ll let you know where and why it happens.\nThe files are prepared for version 4.0, I am going to utilise new bone collections, so this part will look different if you\u0026rsquo;re on the old version of blender. 2. Armature and Skinning # After opening the .blend file, your project should resemble this: View after opening the file To kick things off, let\u0026rsquo;s create armature in the correct axis. Hit NUM3 to align the camera in ortographic mode. Our left side will become the front of the model and our right will become the back. We\u0026rsquo;ll use that knowledge, to create the root bone. Now, add the Armature by pressing SHIFT + A and selecting Armature from the drop-down menu. It will be generated in the middle of the ball. As it\u0026rsquo;s inside the mesh, you might not see it. Head over to the right side - to the Properties tab. Select Armature Data \u0026gt; Viewport Display and enable:\nNames - This option shows bone names, it\u0026rsquo;ll help us in defining bones on screen, without having to look all the time at the outliner. Shapes - It\u0026rsquo;ll let us look at controls later Bone Colors - It\u0026rsquo;ll let us change controller colors later In Front - It\u0026rsquo;ll render bones always in front, super useful for aligning stuff. Axes - It\u0026rsquo;s important for understanding our rotations. Armature Data in outliner Once you\u0026rsquo;ve selected the armature, switch to Edit Mode by pressing CTRL+TAB.\nTo streamline the workflow, head over to Preferences \u0026gt; Keymap and enable \u0026ldquo;Tab for Pie Menu\u0026rdquo; option. This modification allows user to switch modes by pressing TAB key. Moving forward, I\u0026rsquo;ll be using it.\nMode Select Pie Menu While in Edit Mode, select the bone and rename it to \u0026ldquo;root\u0026rdquo; by pressing F2 to enable fast renaming, confirm with ENTER. As mentioned in the past article, the root is always placed in world origin, and that\u0026rsquo;s exactly where we will place ours.\nRename tool In Edit Mode, select the Head and use SHIFT+S to opt for Selection to Cursor. Next, move the head with G. To move it preciesly, click Y, to lock the movement in Y axis. After that, before confirming the transform, hit 1 to move it by 1m in the selected axis.\nChanging the root to world transform by using 3D Cursor To familiarize with the two key functions of the 3D Cursor, let\u0026rsquo;s change the mesh\u0026rsquo;s origin. To do that, move the cursor with 3D Cursor to Active function using SHIFT+S shortcut. In order to do that, hit TABto get back to Object Mode.\nChanging the 3D Cursor to Ball Origin Once that is complete, in next step we\u0026rsquo;re going to create our only def bone, that we will name def_body. To achieve this, select the armature, switch to Edit Mode and select the root bone\u0026rsquo;s Tail. Extrude a bone by pressing E and then lock it in Z axis with Z. Extrude it approximately to the middle of the ball and rename the bone with F2.\nExtruding a bone from root Clean outliner is your friend - rename things as early as possible to de-clutter the project!\nFollowing that, we will move the def_body bone in Z axis by using 3D Cursor. Make sure that this bone is not parented by using ALT+P\u0026gt;Clear Parent. Use SHIFT+S and select Selection to Cursor. Your rig should look like this:\nRig with proper deformation bone placed One crucial step for later is to modify the rotation mode. In Pose Mode, select your bones, and hit CTRL+R. From the dropdown menu select XYZ. It\u0026rsquo;ll become important later!\nNext, we proceed to bind the mesh to the bone in a process called skinning.\nLet\u0026rsquo;s begin by examining each bone in the Bone Data tab in Properties Menu. Make sure that [] Deform checkbox is selected. For the root, leave this unchecked.\nIn blender, bones with the prefix DEF are the only ones that should have deform checked, by doing that you\u0026rsquo;ll know which bones influence your mesh. Besides that, deformation bones are the only ones that are going to be exported into the engine.\nProperties of def_bone with Deform checked Once you\u0026rsquo;ve confirmed that only your deformation bones are actually deforming (and it\u0026rsquo;s indeed a good habit to check them before initiating the skinning process), let\u0026rsquo;s start skinning!.\nReturn to Object Mode, select your mesh, then while holding SHIFT, select your Armature. To bind them, hit CTRL+P and choose Armature Deform - Automatic Weights from the dropdown menu.\nSkinning process with Automatic Weights You might wonder, \u0026ldquo;Why opt for automatic weights? Is it always the optimal choice?\u0026rdquo; Unfortunately, the answer is no. Automatic weights are seldom the ideal solution. While it might suffice for models compromised of a single mesh or multiple distinct meshes (such as mechanical components), I strongly recommend using Empty Groups and manually assigning Vertex Groups to precisely control which parts of the skin are influenced by which bone. However, this process is beyond the scope of this tutorial. Following this, let\u0026rsquo;s chek if our skinning process worked properly. Select the Armature, then in Pose Mode, move root, and then def_body bones to check if the rig works properly. Note: You can quickly reset transformations by pressing ALT+R for rotation, ALT+G for translation and ALT+S for scale.\nChecking if skinning is working right, we\u0026rsquo;ll do it every time after skinning With that, we\u0026rsquo;ve completed the first phase of creating the ball rig in blender. As a next step, go ahead and parent the def_body to the root with an offset. Here\u0026rsquo;s a quick guide in case you\u0026rsquo;re unsure:\nClick to reveal Go to Edit Mode\nSelect def_body, then SHIFT-click root bone\nUse CTRL+P -\u0026gt; Parent With Offset\n3. Making Squash \u0026amp; Stretch mechanism # As we\u0026rsquo;ve discussed the mathematics behind achieving an optimal squash \u0026amp; stretch ratio, blender offers a pre-built constraint that can handle the task for us. While it has advantages, I personally lean towards rigging nodes of Maya.\nThe constraint I\u0026rsquo;m talking about is Stretch To that looks like this:\nScreenshot of Stretch To from blender docs As I am not a fan of explaining perfectly written documentation, here\u0026rsquo;s the link to Stretch To Constraint. Now, let\u0026rsquo;s focus on the key aspects:\nTarget - it\u0026rsquo;ll be the the \u0026ldquo;end point\u0026rdquo; of our squash \u0026amp; stretch target Maintain Volume - it determines which axes should be affected to preserve the virtual volume stretching along Y axis. Let\u0026rsquo;s return to our rig and start creating our stretch mechanism. To begin, duplicate our def_body bone, then select the tail. Next, reset the 3D Cursor with SHIFT+S\u0026gt;3D Cursor To World Origin. You might have some problems selecting the right Tail, so to help with that, let\u0026rsquo;s look into the concept of Bone Collections.\nBone Collection Menu in Properties Tab Consider Bone Collections as akin to layers in other software applications. Since blender 4.0 update, old layer system was revamped to make them unlimited (we had 16 normal + 16 protected before). By utilizing the \u0026ldquo;+\u0026rdquo; button, we can add several layers and configure them to appear like this:\nI\u0026rsquo;ve added five different layers that we\u0026rsquo;re going to use for the whole tutorial The critical aspect to grasp is that if a bone has a dot near the name of the collection when selected, then it\u0026rsquo;s a part of that collection. Consequently, we can hide or unhide them as needed, although they can be in more than one collection. However, it\u0026rsquo;s essential to remember: you cannot parent or unparent bones that are actively hidden!\nLet\u0026rsquo;s sort the bones by their names:\nSorting out the bones to the right layers Having set up the Bone Collections, we can now proceed to create the mch_stretch bone. Let\u0026rsquo;s follow the sequence again: duplicate the def_body bone with SHIFT+D, select the tail and use SHIFT+S\u0026gt;3D Cursor To World Origin. It should snap the bone to the bottom of the ball making the newly created bone go through whole height.\nStretching mch_stretch to it\u0026rsquo;s proper position Taking a glance at our control list, it\u0026rsquo;s evident that we need some additional controls to manage the stretch from both sides. For this purpose, we\u0026rsquo;ll create two additional bones. To maintain a clean rigging structure, we will utilize target bones. They will separate constraints between the deformation skeleton (def) and our controls (ctrl) by having an intermediary target (tgt) skeleton. Think of it as something akin to Maya\u0026rsquo;s offset groups, used to ensure that controllers are always at transform (0, 0, 0). As always - we\u0026rsquo;re building habits that will enhance our rigging skills in the future.\nLet\u0026rsquo;s proceed by extruding two bones on the Z-axis in Edit Mode, one from the bottom and one from the top of the mch_stretch. We\u0026rsquo;ll name them tgt_stretch-top and tgt_stretch-bottom, then hit ALT+P\u0026gt;Clear Parent We are going to extrude two bones on Z axis, one from bottom and one from top of the mch_stretch, we\u0026rsquo;re also going to name them tgt_stretch-top and tgt_stretch-bottom and Clear Parent to let them move independently.\nCreating target bones for the stretch controlls, notice I am checking if the things separated properly For the next step, I\u0026rsquo;ll leave you with some exercises. In the next step, we\u0026rsquo;ll assign appropriate bone collections and create a tgt_body that will be a copy of def_body. Ensure to uncheck the deform option! Additionally, duplicate tgt_body once more and name it tgt_cog.\nOnce completed, our hierarchy should resemble the following:\nroot def_body mch_stretch tgt_stretch-top tgt_stretch-bottom tgt_cog tgt_body Now, to explain how this ball\u0026rsquo;s mechanism will work, we are going to do two things:\nAdd stretchTo to mch_stretch parent things properly Before delving into the why behind this setup, let\u0026rsquo;s add constraints. Switch to Pose Mode and add constraints either by using SHIFT+CTRL+C or through Properties\u0026gt;Bone Constraints. Set Armature as the target and tgt_stretch-top (or bottom) as the bone target. After this, check if it functions as intended.\nWe could also shift-click our target bone \u0026gt; bone we add constraint to to automatically select it Following the constraint addition, let\u0026rsquo;s parent our mechanism properly. Let\u0026rsquo;s re-think what we need:\nFirst, we want to be able to move everythign by tgt_cog, making it the top of the hierarchy. Second, our stretch controllers should follow the cog, so they\u0026rsquo;re going to be children of tgt_cog. For mch_stretch to work in both directions we can make it a child of tgt_stretch-bottom - as bottom and top are on the same level in hierarchy, they\u0026rsquo;ll be independent, so this setup will let us use stretchTo from bottom to tgt_stretch-top and move the stretcher mechanism by moving the bottom while top will stay in place. To maintain independent rotation from the stretch, it should happen \u0026ldquo;under\u0026rdquo; the stretching hierarchy. Therefore, make the rotation occur afterward by making it a child of mch_stretch. This results in a hierarchy like this:\nroot def_body tgt_cog tgt_stretch-top tgt_stretch-bottom mch_stretch tgt_body While it might be hard to remember how Parent actually works, think that it\u0026rsquo;s always CHILDREN first being grabbed by PARENT at last 4. Controls # Even though besides rigging I am also an animator, I always plan my controls like I\u0026rsquo;d be rigging for someone else - that\u0026rsquo;s part of my design experience legacy. That\u0026rsquo;s why, we\u0026rsquo;ll tackle planning the controls like we would plan user experience.\nWhile rigging, one should aim to create systems that are easy to understand and as hard to break as possible. That\u0026rsquo;s why normally you\u0026rsquo;d want to layer things in a way, that is possible to fiddle with for people with more technical knowledge, but not too simple to break too easy. For example - looking at antCGI\u0026rsquo;s way of setting up projects in Maya, I really love creating stuff that are DO_NOT_TOUCH to properly mention what parts are going to break the whole rig.\nAs blender outliner collections work differently than Maya ones, we achieved some kind of this grouping with target bones. That\u0026rsquo;s why we are going to create a set on controls on top, so animators won\u0026rsquo;t have to work withing specific system of bones and give them more quality-of-life selecting.\nTO kick things off, our initial step is going to make deformation bones follow our target skeleton. Since we\u0026rsquo;re dealing with just one deformation bone, it\u0026rsquo;ll be straightforward. That\u0026rsquo;s why I want you to do it yourself!.\nThe goal is to add a Copy Transforms constraint to def_body and select tgt_body as the target. You can use either bone properties, or go to Pose Mode and use SHIFT+CTRL+C shortcut. To remember it easy: you always add the constraint to the last bone you\u0026rsquo;ve selected.\nIt should look like this, if you can\u0026rsquo;t select it - unhide def bone collection Now, let\u0026rsquo;s check if every target bone works properly.\nA quick look if we can do everything even if we disable other bones than target ones If everything works, let\u0026rsquo;s dive into setting up some cool looking controls! Grab Bone Widget before we get started.\nFirst off, we\u0026rsquo;re going to talk about different types of controls and shapes one might associate with specific bone names. If we look at the hierarchy, at the top we have a root. If you didn\u0026rsquo;t know, blender actually creates root everytime - it\u0026rsquo;s actually the Armature itself - that\u0026rsquo;s why technically you could export your skeleton without root, but 2-level root is a standard in rigging these days. It gives more control and is used in some techniques, that I might touch in the future. For us the most important thing to understand is that the root bone mimics in-engine capsule.\nLet\u0026rsquo;s explore some popular shapes:\nVayne Rig by Matheus Lima @ artstation AZRI Rig by popular autor Jonathan Cooper, author of GameAnim: Video Games Explained Uncle Death Rig for blender by Crabnuts (@Kani_Natto_), blender rig controls are generally lighter and less saturated I\u0026rsquo;m sure you\u0026rsquo;ve come across a variety of them - circular, sometimes squared, with or without arrows. In Bone Widget, we\u0026rsquo;ve got the choice of two options (named Root 1 and Root 2), and for the Vayne-styled look (my preferable), let\u0026rsquo;s go with Root 1.\nTo start, duplicate a bone of root and give it the name ctrl_root. Don\u0026rsquo;t forget to clean things up within the Bone Layers. Since our controls will mirror the target bone hierarchy, you can safely leave it hanging out under Armature without any worries.\nWe can easily leave it in hierarchy as we\u0026rsquo;ll mimic target one Moving on, let\u0026rsquo;s switch over to Pose Mode and hit N, to pop open the sidebar. Navigate to Rig Tools and open up Bone Widget. Next, Select Root 1 as the shape and click Create to change the bone\u0026rsquo;s shape.\nOnce you\u0026rsquo;ve nailed that, here\u0026rsquo;s a straightforward exercise for you: duplicate all the target bones and rename them as ctrl_*, where * represents the relative name. Skip copying the mch bone, because mechanisms aren\u0026rsquo;t controls. After this, set up the parenting to mimic the target bone hierarchy.\nNow, here\u0026rsquo;s the trick I\u0026rsquo;ve been hinting at: do not duplicate tgt_body. Instead, we\u0026rsquo;ll make it a control (so you can add it to ctrl collection). This step is crucial to avoid rotation glitches.\nRemember to add them to collections afterwards Now, we need our target bones to follow controls, so let\u0026rsquo;s add copy transform from controls to targets. This time, we\u0026rsquo;re going to do it faster - by SHIFT clicking first ctrl, then tgt bone and using the same shortcut as with the deformation bone - SHIFT+CTRL+C.\nIf you cant click the bone, you can always select it in outliner Let\u0026rsquo;s brainstorm about our other controls - beginning with ctrl_cog and tgt_body. A standard cog (sometimes referred to as hips) is usually a big circle around \u0026ldquo;hips\u0026rdquo; area. We\u0026rsquo;ll roll with it, also creating a smaller circle for the rotation purposes. When you add a shape, keep in mind that you can tweak its dimensions by hitting the Edit button, allowing you to resize the controls.\nYou can notice, that I\u0026rsquo;ve forgotten to add tgt_body to the right collection before and it didn\u0026rsquo;t let me create shape because tgt was hidden When it comes to stretching controls, their design can vary from one rig to another. However, for our rig, let\u0026rsquo;s categorize them as auxiliary controls. This implies that we need to create a shape that conveys the purpose behind its function, enabling animators to grasp how to manipulate the controller as naturally as possible. Think of control design as a form of UX of rigging techniques - incorporating markers that, through form, shape, or color, subtly guide users on how to interact with our rigs. If you\u0026rsquo;re interested in delving deeper into the concept of markers in design, Donald Norman\u0026rsquo;s The Design of Everyday Things is a great resource.\nAs my choice for markers, I\u0026rsquo;ve settled on pyramids. Their pointy side naturally guides the eye towards the ball, creating an intuitive sense that translating the controller towards the inside will produce a certain effect, probably toward the center of the ball. Now that we\u0026rsquo;ve looked into my process, feel free to add them yourself. By the end, your setup should look similar to this:\nIf you select two bones, you can add the same shape at the same time! As you can observe, my pyamids are a bit smaller and shifter outwards. You can achieve this effect either by utilizing the Edit option or by accessing the menu that appears in the bottom-left corner. Experiment with these features to fine-tune the size and positioning to match your design!\nAfter gaining experience with enough rigs, you\u0026rsquo;ll likely notice that colors in rigging tend to follow similar patterns, regardless of the author. I\u0026rsquo;ve developed my own control scheme, which I\u0026rsquo;m excited to share with you:\nLeft side controls are BLUE Right side controls are RED Middle side controls are YELLOW Auxilary controls are GREEN To change the control colors, navigate to Bone\u0026gt;Viewport Display in Properties tab. I typically opt for a custom color theme, utilizing the adjacent button to copy the color scheme to other colors (with the source object being the LAST selected).\nGive it a shot by selecting ctrl_stretch-top, navigating to it\u0026rsquo;s Viewport Display tab and adding a custom color theme with a vibrant green shade. Once set, select the remaining auxiliary controls and hit the double arrow button to match these colors.\nBlender uses a specific setup where you give 3 colors - Regular / Select / Active Since you\u0026rsquo;re now adept at adding control colors, let\u0026rsquo;s bring this to a close by adding them into the remaining controllers. Your final result should resemble this:\nWe\u0026rsquo;ve almost done! 5. Clean up \u0026amp; final touches # Now that we\u0026rsquo;ve build everything, you might be tempted to dive straight into animation.\nHold on!\nRemember, I mentioned that a mess can be a real headache later, so let\u0026rsquo;s wrap up with some final cleanup.\nWe\u0026rsquo;ll start with Armature Tab - we can finally check off Names, In Front and Axes tab - animators don\u0026rsquo;t really need them and if they need to have controls in front, they\u0026rsquo;ll set them up.\nYour rig should look like this Before we conclude, let\u0026rsquo;s address one more crucial aspect: locking certain transforms. Althoguh I\u0026rsquo;m usually in favor of providing animators with flexibility (of not locking their transforms), there are instances where a bit of guidance can enhance their animation experience.\nLet\u0026rsquo;s begin with the stretch controllers. While animators can manipulate these with transform (location), rotation and scale are only going to make the controls spin/scale without any influence over the rig - to streamline usage, we can lock these transforms, allowing animators to control the squashing effortlessly by simply pressing G.\nThe last thing we should think about is locking up some transforms - I am generally against limiting animators choices, but there are some things we can do, to help animators in their work.\nYou can hold LMB and drag to lock more than one thing at a time After this, let\u0026rsquo;s consider the rotation control. We don\u0026rsquo;t really need the scale, so it should be locked. Rotation is the primary focus, so that should remain open. What about location? There are two schools of thought on this. Some prefer locking it out since the control isn\u0026rsquo;t meant for translation. However, as stated earlier, I believe it\u0026rsquo;s better to leave it open. Animators can discern if they\u0026rsquo;ve added a keyframe to the wrong controller and rectify it themselves. Moreover, they might need to detach the translation to two different bones, and this setup facilitates that. Keep in mind that leaving the location unlocked might affect some squash transforms (if you really try to break the setup) - ultimately the decision is yours.\nMoving onto the cog, as the main control for moving the mesh, both location and rotation should be open. However, for the scale, I suggest locking it to prevent potential bugs.\nFinally - the root control - certaintly, location and rotation should be unlocked. Regarding scale, with our setup of maintaining a consistent hierarchy, users can easily scale the root to achieve different sizes easily. Controls will scale proportionally, ensuring the rig functions seamlessly. However, scalability isn\u0026rsquo;t always straightforward in rigging and careful consideration is needed when designing controls.\n6. Closing Thoughts # Congratulations on successfully rigging your first ball! Now, you can embark on your animation journey, starting with bouncing ball exercises. Additionally, you\u0026rsquo;ve gained insights into planning controls and naming conventions, which will prove invaluable in your future endeavors.\nIf you\u0026rsquo;re as excited as I am, I won\u0026rsquo;t keep you any longer. After mastering the ball, the animation world is yours to explore!\nHappy animating!\nAnd if you choose to share you ball animation, tag me (@arahfx) - I\u0026rsquo;d love to see your creations!\n","date":"17 March 2024","externalUrl":null,"permalink":"/posts/202403-squashstretch_blender/","section":"Posts","summary":"A step by step guide to build your first ball rig in blender","title":"Squash \u0026 Stretch Ball in blender","type":"posts"},{"content":"","date":"17 March 2024","externalUrl":null,"permalink":"/series/squash--stretch-ball-rig/","section":"Series","summary":"","title":"Squash \u0026 Stretch Ball Rig","type":"series"},{"content":"","date":"16 March 2024","externalUrl":null,"permalink":"/tags/theory/","section":"Tags","summary":"","title":"Theory","type":"tags"},{"content":" 0. Foreword # In this article you\u0026rsquo;ll learn:\nThe importance of ball exercises for learning animation Basic idea on what Ball Rig consist of Learn common slang for some controller types Understand what is happening in the code of \u0026ldquo;stretch\u0026rdquo; modifiers in popular programs 1. Why is ball important? # Whether you\u0026rsquo;re just starting your animation journey, study the craft, or you\u0026rsquo;re a seasoned animation veteran - the foundation of everything you know about animation starts with a ball.\nIf we take a cue at Richard William\u0026rsquo;s The Animator\u0026rsquo;s Survival Kit, the first chapter titled IT\u0026rsquo;S ALL IN THE TIMING AND THE SPACING - delves into how we use these two terms to understand the basics of any motion.\nI\u0026rsquo;ll never forget the image of this big Norwegian American sitting in the golden twilight, extending his long arms and spatula hands saying\u0026hellip; «The bouncing ball says it all»\n\u0026ndash; R. Williams \u0026ldquo;The Animators Survival Kit\u0026rdquo; That\u0026rsquo;s why I want my first post to be dedicated to building a proper ball rig - a foundation upon one can explore basics of spacing, timing and squash \u0026amp; stretch principles. Additionally, we\u0026rsquo;ll peek under the hood of rigging mesh that can preserve it\u0026rsquo;s volume while being scaled.\nOf course, in 3D animation there are two main groups of users: Autodesk Maya and blender. I\u0026rsquo;ll try to explain the ideas in a software-agnostic manner. However, there will be chapters dedicated to one software, but I\u0026rsquo;m going to write every tutorial for both sofwares - ensuring noone feels left out.\nI\u0026rsquo;ll be using some scripts along the way, presented like this:\nExample - so you can install it yourself and follow along.\nFurthermore, I\u0026rsquo;ll include rigs created in the tutorials - fully functional and suitable for use as foundational animation tutorials. They will be provided totally free of charge and licensed under GPL v3.0.\nIf you\u0026rsquo;re interested in delving into the technical aspects of animation, let\u0026rsquo;s get started!\n3. What is actually squash \u0026amp; stretch? # You\u0026rsquo;re probably familiar with the concept of squashing and stretching - it seems deceptively simple. When we squash a water balloon, the water inside pushes the sides, giving it a pancake-like appearance. Upon release, it springs back to its more natural shape, and if thrown - it stretches in the air before squashing upon impact.\nA balloon squashing on a face, courtesy of gifer.com Disney\u0026rsquo;s Nine Old Men identified squashing and stretching as one of the most crucial principles for creating visually appealing animation. It holds such significance that they designate dit as the the #1 principle in their 12 Principles of Animation. Understanding this principle is a cornerstone for today\u0026rsquo;s animators, whether they\u0026rsquo;re sketching frames or manipulating a complex humanoid body. Accounting for squash and stretch is essential to achieving the elusive illusion of life.\nThe mathematical explanation # Let\u0026rsquo;s start by eating the frog. In mathematical terms, we\u0026rsquo;ll consider a sphere with dimensions of x, y and z and a volume V1. We will then manipulate it by multiplying by n in one direction and by \\(\\frac{1}{\\sqrt{n}}\\) in the other directions. This manipulation aims to achieve a new volume V2 that remains equal to V1.\n\\(\\text{Volume} = x \\cdot y \\cdot z = n \\cdot y \\cdot \\left(\\frac{x}{\\sqrt{n}}\\right) \\cdot \\left(\\frac{z}{\\sqrt{n}}\\right)\\)\nWhere: x, y, z - our sphere transform values\nn - the amount of change along we add, in this case along Y axis\nRigging explanation # When it comes to rigging, achieving a volume preservation effect can be approached in various ways based on the intended use and desired outcome.\nThose of you who transition to animation from modelling, the first technique that may come to mind is the Lattice Deformer.\nLattice around the cube object in Object Mode - from blender official docs Lattice is a deformer present both in blender and Maya, commonly used for applying deformation. However, for our purposes where a deformation cage can be constrained and controlled, it might not be the most versatile method for creating mesh deformations. Despite encountering numerous YouTube tutorials utilizing such approach, I won\u0026rsquo;t be delving into this method in the upcoming ball rig tutorials.\nSquash deformer results - from Maya docs Second method, more aligned with the rigging tools themselves, involves using Stretch To Constraint (in blender)/ Squash Deformer (in Maya). These are off-the-shelf features that can significantly simplify construction of said mechanism in rigging. However, they might have limitations in more advanced setups.\nAs of version 4.0, blender hasn\u0026rsquo;t introduced rigging nodes yet, we\u0026rsquo;ll be utilizing Stretch To Constraint in the blender-specific tutorial. But how does it work under the hood?\nThe fundamental concept behind volume-preservating squash \u0026amp; stretch is joint scaling. When we stretch an object, it\u0026rsquo;s joint (or chain of joints) undergoes scaling. Of course when it squashes, the chain naturally scales too. This scaling can be applied uniformly along all axes - providing full-scaling of the rig or selectively along specific axes. To mimic the simultaneous change if onther axes, we can use the Volume ratio presented before.\nLet\u0026rsquo;s try this example.\nTo illustrate this, let\u0026rsquo;s assume we have an object whose transforms are (x, y, z).\nWe can stretch the bone by vector \\(\\vec{v}\\) = [0, 1, 0] resulting in new transform:\n(x, y+1, z)\nBy knowing the new value of y transform, we can calculate n.\nTo sell the effect of stretching, we need to scale the same object in other axes to achieve the same volume. To achieve that, we\u0026rsquo;ll use the formula I\u0026rsquo;ve written about before.\nWhen we scale object in y axis by n, we\u0026rsquo;ll multiply x and z scale by \\(\\frac{1}{\\sqrt{n}}\\) - to preserve the volume of the object.\nIn Maya\u0026rsquo;s Rigging Node Editor, it is possible to connect x, y and z direclty with multiplyDivide node, to multiply these channels accordingly. This method is going to achieve a good squash \u0026amp; stretch that is going to work on all type of bone chains - it\u0026rsquo;s extremly useful for humanoid skeleton rigs with cartoon features!\nSquash \u0026amp; Stretch in video games # Squash \u0026amp; Stretch isn\u0026rsquo;t something you\u0026rsquo;ll often encounter in videogames, at least now by default.\nUnreal Engine, for instance, doesn\u0026rsquo;t export scale of deformation bones at all! This might prompt one simple question - why bother?. The reason behind this decision is quite substantial. Achieving a good looking, volume-preserving squash \u0026amp; stretch of Skeletal Mesh entails calculating skinning deformations every frame, making it one of the most resource-hungry tasks for player\u0026rsquo;s CPU. While enabling bone scaling during mesh import is an option to preserve these effects, it\u0026rsquo;s typically not the default setting due to performance problems. In many cases, this decision alligns with overall optimization strategies - it\u0026rsquo;s going to be used only when the game really depends on it.\nGiven the heavy optimization implications, there\u0026rsquo;are other techniques that might mimic the feeling of squashing and stretching in video games. These often include translations of the skeleton, mostly adjustments to arms and legs. Let\u0026rsquo;s consider jumping - by translating parts of skeleton one can achieve a stronger, more dynamic pose, for example by leaving the legs for a few frames on the ground longer only to squash them together (to their original position) nearing the apex of the jump loop. Such technique of translation can be observed in World of Warcraft\u0026rsquo;s Pandaren Jump.\nPandaren jump loop probably my favourite WoW animation These are just a few examples of the different tricks animators employ to create the illusion of life, even though it may not involve the real calculated volume-preserving squash \u0026amp; stretch. After all, the ultimate goal is to sell the viewer the best looking, lively performance withing the constraints of game performance.\n3. How does a ball rig work? # Mesh # For this example I\u0026rsquo;ll be using a mesh with a checker texture, that you can download:\nFor blender here Skeleton # In it\u0026rsquo;s simplest form, a ball skeleton consists of just one bone, where joints (Maya) / head and tail of the bone (blender) are touching the sphere\u0026rsquo;s base and end. These hold whole skinning information, making it an ideal object to use automatic skinning options for.\nControls # Considering what animator might need to control in a ball rig, we might think of a few cases.\nFor blender I\u0026rsquo;m going to use Bone Widget to create control shapes. Every rig, at the top of it\u0026rsquo;s hierarchy has to have a root. It\u0026rsquo;s purpose is to hold information about the default space of the rig. It\u0026rsquo;s often represented by a variation of circles with arrows on the ground.\nPossible shapes of root bones using Bone Widget The next in hierarchy, overarching rest of the controllers is a bone called cog - or sometimes stylized as c.o.g (abbreviation for center of gravity). These might get a lot different shapes depending of the center of gravity shape. The most popular ones are circles and saddles, for the purpose of ball rig, we\u0026rsquo;ll use a big circle.\nA Saddle-like shape for cog from Bone Widget The hierarchy of the rest of controllers might differ depending on circumstances. In case of our ball rig, we\u0026rsquo;ll have a few controllers following a cog. First of them will be a rotor - our second level controller. In this case rotor will be working the same as the cog - it\u0026rsquo;ll let animators translate or rotate a mesh (unless we lock it) and it\u0026rsquo;s main purpose will be to split rotation and translation to avoid clutter in the timeline and graph editor. We\u0026rsquo;ll use a smaller circle for this controller.\nThe last type of controllers for this rig is going to be an auxilary controller that will let animator control the squash and stretch of the mesh - preferably from the top and botton. There is no one way to imagine general shape of these controllers - their shape are going to refer to their function. In our case it\u0026rsquo;s going to be a control that might move up and down, so something with a pointy end might be a good idea. We\u0026rsquo;ll talk more about specific shapes in the next chapters.\n4. Closing Thoughts # We explored the concept of squash and stretch, delving into its significance and mechanics. Our discussion included its importance in animation and various ways to mimic it when necessary. Additionally, we laid down the foundational theory for building a functional ball rig.\nArmed with this knowledge, the upcoming articles will take a hands-on approach, applying the knowledge to create a working ball rig that you\u0026rsquo;ll be able to animate yourself. If you have any further questions of need assistance, dont hesitate to ask.\nIf you want to put the new knowledge to use - we\u0026rsquo;ll going to build the ball rig in blender in next article.\nHappy rigging!\n","date":"16 March 2024","externalUrl":null,"permalink":"/posts/202403-squashstretch/","section":"Posts","summary":"Overlook of squash \u0026amp; stretch mechanism building with with different rigging approaches","title":"Theory behind building a squash \u0026 stretch rig","type":"posts"},{"content":"After overcoming some challanges of webdev (and trying to understand how networks and DNSes actually work) I am thrilled to extend a warm welcome to my personal website! I envision this space evolving over time to not only serve as my online portfolio/professional site but also as a digitalized repository of my Notion/Confluence notes and tutorials on animation, rigging and working with blender/Maya/Unreal Engine and possibly other DCC softwares. My hope is that it becomes a valuable resource for anyone who stumbles upon this site.\nIn addition, I\u0026rsquo;ve taken the opportunity to apply my front-end webdev skills (probably absorbed while working within front-dev team as UX/UI designer some time ago), I am actually using GoHugo framework using the beautiful Blowfish theme! I\u0026rsquo;ve also took my time to properly setup everything to work on GitHub Pages.\nAs this posts marks the first blogpost, what better way to start than:\nHello World! # Ps. Stay tuned for more updates and tutorials.\n","date":"13 March 2024","externalUrl":null,"permalink":"/posts/202403-helloworld/","section":"Posts","summary":"A launch/welcome post","title":"Hello world!","type":"posts"},{"content":"","date":"13 March 2024","externalUrl":null,"permalink":"/tags/notes/","section":"Tags","summary":"","title":"Notes","type":"tags"},{"content":"","date":"13 March 2024","externalUrl":null,"permalink":"/tags/reflections/","section":"Tags","summary":"","title":"Reflections","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]