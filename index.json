[{"content":"","date":"22 February 2024","permalink":"/adamblogstuff/tags/beginner/","section":"Tags","summary":"","title":"Beginner"},{"content":"","date":"22 February 2024","permalink":"/adamblogstuff/tags/blender/","section":"Tags","summary":"","title":"Blender"},{"content":"","date":"22 February 2024","permalink":"/adamblogstuff/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"22 February 2024","permalink":"/adamblogstuff/tags/rigging/","section":"Tags","summary":"","title":"Rigging"},{"content":"","date":"22 February 2024","permalink":"/adamblogstuff/series/rigging-for-beginner-animation/","section":"Series","summary":"","title":"Rigging for Beginner Animation"},{"content":"","date":"22 February 2024","permalink":"/adamblogstuff/series/","section":"Series","summary":"","title":"Series"},{"content":"Rigging the squash \u0026amp; stretch ball in blender # 0. Foreword # In this article you\u0026rsquo;ll learn:\nHow to rig a ball in blender How to create armatures and move them to snap bones in place How to use Bone Widget to create controls How to keep your rig and project file clean Basics of preparing rig for usage by other people 1. Preparation # For our blender ball rig, we\u0026rsquo;re start by downloading the project files and Bone Widget.\nHeads up: As of the publication day, blender doesn\u0026rsquo;t use riging nodes, that\u0026rsquo;s why we\u0026rsquo;ll need to do little hacking in the controllers hierarchy, that I\u0026rsquo;ll try to avoid later in the series, I\u0026rsquo;ll let you know where and why it happens.\nThe files are prepared for version 4.0, I am going to utilise new bone collections, so this part will look different if you\u0026rsquo;re on the old version of blender. 2. Armature and Skinning # After opening the .blend file, your project should resemble this: View after opening the file To kick things off, let\u0026rsquo;s create armature in the correct axis. Hit NUM3 to align the camera in ortographic mode. Our left side will become the front of the model and our right will become the back. We\u0026rsquo;ll use that knowledge, to create the root bone. Now, add the Armature by pressing SHIFT + A and selecting Armature from the drop-down menu. It will be generated in the middle of the ball. As it\u0026rsquo;s inside the mesh, you might not see it. Head over to the right side - to the Properties tab. Select Armature Data \u0026gt; Viewport Display and enable:\nNames - This option shows bone names, it\u0026rsquo;ll help us in defining bones on screen, without having to look all the time at the outliner. Shapes - It\u0026rsquo;ll let us look at controls later Bone Colors - It\u0026rsquo;ll let us change controller colors later In Front - It\u0026rsquo;ll render bones always in front, super useful for aligning stuff. Axes - It\u0026rsquo;s important for understanding our rotations. Armature Data in outliner Once you\u0026rsquo;ve selected the armature, switch to Edit Mode by pressing CTRL+TAB.\nTo streamline the workflow, head over to Preferences \u0026gt; Keymap and enable \u0026ldquo;Tab for Pie Menu\u0026rdquo; option. This modification allows user to switch modes by pressing TAB key. Moving forward, I\u0026rsquo;ll be using it.\nMode Select Pie Menu While in Edit Mode, select the bone and rename it to \u0026ldquo;root\u0026rdquo; by pressing F2 to enable fast renaming, confirm with ENTER. As mentioned in the past article, the root is always placed in world origin, and that\u0026rsquo;s exactly where we will place ours.\nRename tool In Edit Mode, select the Head and use SHIFT+S to opt for Selection to Cursor. Next, move the head with G. To move it preciesly, click Y, to lock the movement in Y axis. After that, before confirming the transform, hit 1 to move it by 1m in the selected axis.\nChanging the root to world transform by using 3D Cursor To familiarize with the two key functions of the 3D Cursor, let\u0026rsquo;s change the mesh\u0026rsquo;s origin. To do that, move the cursor with 3D Cursor to Active function using SHIFT+S shortcut. In order to do that, hit TABto get back to Object Mode.\nChanging the 3D Cursor to Ball Origin Once that is complete, in next step we\u0026rsquo;re going to create our only def bone, that we will name def_body. To achieve this, select the armature, switch to Edit Mode and select the root bone\u0026rsquo;s Tail. Extrude a bone by pressing E and then lock it in Z axis with Z. Extrude it approximately to the middle of the ball and rename the bone with F2.\nExtruding a bone from root Clean outliner is your friend - rename things as early as possible to de-clutter the project!\nFollowing that, we will move the def_body bone in Z axis by using 3D Cursor. Make sure that this bone is not parented by using ALT+P\u0026gt;Clear Parent. Use SHIFT+S and select Selection to Cursor. Your rig should look like this:\nRig with proper deformation bone placed One crucial step for later is to modify the rotation mode. In Pose Mode, select your bones, and hit CTRL+R. From the dropdown menu select XYZ. It\u0026rsquo;ll become important later!\nNext, we proceed to bind the mesh to the bone in a process called skinning.\nLet\u0026rsquo;s begin by examining each bone in the Bone Data tab in Properties Menu. Make sure that [] Deform checkbox is selected. For the root, leave this unchecked.\nIn blender, bones with the prefix DEF are the only ones that should have deform checked, by doing that you\u0026rsquo;ll know which bones influence your mesh. Besides that, deformation bones are the only ones that are going to be exported into the engine.\nProperties of def_bone with Deform checked Once you\u0026rsquo;ve confirmed that only your deformation bones are actually deforming (and it\u0026rsquo;s indeed a good habit to check them before initiating the skinning process), let\u0026rsquo;s start skinning!.\nReturn to Object Mode, select your mesh, then while holding SHIFT, select your Armature. To bind them, hit CTRL+P and choose Armature Deform - Automatic Weights from the dropdown menu.\nSkinning process with Automatic Weights You might wonder, \u0026ldquo;Why opt for automatic weights? Is it always the optimal choice?\u0026rdquo; Unfortunately, the answer is no. Automatic weights are seldom the ideal solution. While it might suffice for models compromised of a single mesh or multiple distinct meshes (such as mechanical components), I strongly recommend using Empty Groups and manually assigning Vertex Groups to precisely control which parts of the skin are influenced by which bone. However, this process is beyond the scope of this tutorial. Following this, let\u0026rsquo;s chek if our skinning process worked properly. Select the Armature, then in Pose Mode, move root, and then def_body bones to check if the rig works properly. Note: You can quickly reset transformations by pressing ALT+R for rotation, ALT+G for translation and ALT+S for scale.\nChecking if skinning is working right, we\u0026rsquo;ll do it every time after skinning With that, we\u0026rsquo;ve completed the first phase of creating the ball rig in blender. As a next step, go ahead and parent the def_body to the root with an offset. Here\u0026rsquo;s a quick guide in case you\u0026rsquo;re unsure:\nClick to reveal Go to Edit Mode\nSelect def_body, then SHIFT-click root bone\nUse CTRL+P -\u0026gt; Parent With Offset\n3. Making Squash \u0026amp; Stretch mechanism # As we\u0026rsquo;ve discussed the mathematics behind achieving an optimal squash \u0026amp; stretch ratio, blender offers a pre-built constraint that can handle the task for us. While it has advantages, I personally lean towards rigging nodes of Maya.\nThe constraint I\u0026rsquo;m talking about is Stretch To that looks like this:\nScreenshot of Stretch To from blender docs As I am not a fan of explaining perfectly written documentation, here\u0026rsquo;s the link to Stretch To Constraint. Now, let\u0026rsquo;s focus on the key aspects:\nTarget - it\u0026rsquo;ll be the the \u0026ldquo;end point\u0026rdquo; of our squash \u0026amp; stretch target Maintain Volume - it determines which axes should be affected to preserve the virtual volume stretching along Y axis. Let\u0026rsquo;s return to our rig and start creating our stretch mechanism. To begin, duplicate our def_body bone, then select the tail. Next, reset the 3D Cursor with SHIFT+S\u0026gt;3D Cursor To World Origin. You might have some problems selecting the right Tail, so to help with that, let\u0026rsquo;s look into the concept of Bone Collections.\nBone Collection Menu in Properties Tab Consider Bone Collections as akin to layers in other software applications. Since blender 4.0 update, old layer system was revamped to make them unlimited (we had 16 normal + 16 protected before). By utilizing the \u0026ldquo;+\u0026rdquo; button, we can add several layers and configure them to appear like this:\nI\u0026rsquo;ve added five different layers that we\u0026rsquo;re going to use for the whole tutorial The critical aspect to grasp is that if a bone has a dot near the name of the collection when selected, then it\u0026rsquo;s a part of that collection. Consequently, we can hide or unhide them as needed, although they can be in more than one collection. However, it\u0026rsquo;s essential to remember: you cannot parent or unparent bones that are actively hidden!\nLet\u0026rsquo;s sort the bones by their names:\nSorting out the bones to the right layers Having set up the Bone Collections, we can now proceed to create the mch_stretch bone. Let\u0026rsquo;s follow the sequence again: duplicate the def_body bone with SHIFT+D, select the tail and use SHIFT+S\u0026gt;3D Cursor To World Origin. It should snap the bone to the bottom of the ball making the newly created bone go through whole height.\nStretching mch_stretch to it\u0026rsquo;s proper position Taking a glance at our control list, it\u0026rsquo;s evident that we need some additional controls to manage the stretch from both sides. For this purpose, we\u0026rsquo;ll create two additional bones. To maintain a clean rigging structure, we will utilize target bones. They will separate constraints between the deformation skeleton (def) and our controls (ctrl) by having an intermediary target (tgt) skeleton. Think of it as something akin to Maya\u0026rsquo;s offset groups, used to ensure that controllers are always at transform (0, 0, 0). As always - we\u0026rsquo;re building habits that will enhance our rigging skills in the future.\nLet\u0026rsquo;s proceed by extruding two bones on the Z-axis in Edit Mode, one from the bottom and one from the top of the mch_stretch. We\u0026rsquo;ll name them tgt_stretch-top and tgt_stretch-bottom, then hit ALT+P\u0026gt;Clear Parent We are going to extrude two bones on Z axis, one from bottom and one from top of the mch_stretch, we\u0026rsquo;re also going to name them tgt_stretch-top and tgt_stretch-bottom and Clear Parent to let them move independently.\nCreating target bones for the stretch controlls, notice I am checking if the things separated properly For the next step, I\u0026rsquo;ll leave you with some exercises. In the next step, we\u0026rsquo;ll assign appropriate bone collections and create a tgt_body that will be a copy of def_body. Ensure to uncheck the deform option! Additionally, duplicate tgt_body once more and name it tgt_cog.\nOnce completed, our hierarchy should resemble the following:\nroot def_body mch_stretch tgt_stretch-top tgt_stretch-bottom tgt_cog tgt_body Now, to explain how this ball\u0026rsquo;s mechanism will work, we are going to do two things:\nAdd stretchTo to mch_stretch parent things properly Before delving into the why behind this setup, let\u0026rsquo;s add constraints. Switch to Pose Mode and add constraints either by using SHIFT+CTRL+C or through Properties\u0026gt;Bone Constraints. Set Armature as the target and tgt_stretch-top (or bottom) as the bone target. After this, check if it functions as intended.\nWe could also shift-click our target bone \u0026gt; bone we add constraint to to automatically select it Following the constraint addition, let\u0026rsquo;s parent our mechanism properly. Let\u0026rsquo;s re-think what we need:\nFirst, we want to be able to move everythign by tgt_cog, making it the top of the hierarchy. Second, our stretch controllers should follow the cog, so they\u0026rsquo;re going to be children of tgt_cog. For mch_stretch to work in both directions we can make it a child of tgt_stretch-bottom - as bottom and top are on the same level in hierarchy, they\u0026rsquo;ll be independent, so this setup will let us use stretchTo from bottom to tgt_stretch-top and move the stretcher mechanism by moving the bottom while top will stay in place. To maintain independent rotation from the stretch, it should happen \u0026ldquo;under\u0026rdquo; the stretching hierarchy. Therefore, make the rotation occur afterward by making it a child of mch_stretch. This results in a hierarchy like this:\nroot def_body tgt_cog tgt_stretch-top tgt_stretch-bottom mch_stretch tgt_body While it might be hard to remember how Parent actually works, think that it\u0026rsquo;s always CHILDREN first being grabbed by PARENT at last 4. Controls # Even though besides rigging I am also an animator, I always plan my controls like I\u0026rsquo;d be rigging for someone else - that\u0026rsquo;s part of my design experience legacy. That\u0026rsquo;s why, we\u0026rsquo;ll tackle planning the controls like we would plan user experience.\nWhile rigging, one should aim to create systems that are easy to understand and as hard to break as possible. That\u0026rsquo;s why normally you\u0026rsquo;d want to layer things in a way, that is possible to fiddle with for people with more technical knowledge, but not too simple to break too easy. For example - looking at antCGI\u0026rsquo;s way of setting up projects in Maya, I really love creating stuff that are DO_NOT_TOUCH to properly mention what parts are going to break the whole rig.\nAs blender outliner collections work differently than Maya ones, we achieved some kind of this grouping with target bones. That\u0026rsquo;s why we are going to create a set on controls on top, so animators won\u0026rsquo;t have to work withing specific system of bones and give them more quality-of-life selecting.\nTO kick things off, our initial step is going to make deformation bones follow our target skeleton. Since we\u0026rsquo;re dealing with just one deformation bone, it\u0026rsquo;ll be straightforward. That\u0026rsquo;s why I want you to do it yourself!.\nThe goal is to add a Copy Transforms constraint to def_body and select tgt_body as the target. You can use either bone properties, or go to Pose Mode and use SHIFT+CTRL+C shortcut. To remember it easy: you always add the constraint to the last bone you\u0026rsquo;ve selected.\nIt should look like this, if you can\u0026rsquo;t select it - unhide def bone collection Now, let\u0026rsquo;s check if every target bone works properly.\nA quick look if we can do everything even if we disable other bones than target ones If everything works, let\u0026rsquo;s dive into setting up some cool looking controls! Grab Bone Widget before we get started.\nFirst off, we\u0026rsquo;re going to talk about different types of controls and shapes one might associate with specific bone names. If we look at the hierarchy, at the top we have a root. If you didn\u0026rsquo;t know, blender actually creates root everytime - it\u0026rsquo;s actually the Armature itself - that\u0026rsquo;s why technically you could export your skeleton without root, but 2-level root is a standard in rigging these days. It gives more control and is used in some techniques, that I might touch in the future. For us the most important thing to understand is that the root bone mimics in-engine capsule.\nLet\u0026rsquo;s explore some popular shapes:\nVayne Rig by Matheus Lima @ artstation AZRI Rig by popular autor Jonathan Cooper, author of GameAnim: Video Games Explained Uncle Death Rig for blender by Crabnuts (@Kani_Natto_), blender rig controls are generally lighter and less saturated I\u0026rsquo;m sure you\u0026rsquo;ve come across a variety of them - circular, sometimes squared, with or without arrows. In Bone Widget, we\u0026rsquo;ve got the choice of two options (named Root 1 and Root 2), and for the Vayne-styled look (my preferable), let\u0026rsquo;s go with Root 1.\nTo start, duplicate a bone of root and give it the name ctrl_root. Don\u0026rsquo;t forget to clean things up within the Bone Layers. Since our controls will mirror the target bone hierarchy, you can safely leave it hanging out under Armature without any worries.\nWe can easily leave it in hierarchy as we\u0026rsquo;ll mimic target one Moving on, let\u0026rsquo;s switch over to Pose Mode and hit N, to pop open the sidebar. Navigate to Rig Tools and open up Bone Widget. Next, Select Root 1 as the shape and click Create to change the bone\u0026rsquo;s shape.\nOnce you\u0026rsquo;ve nailed that, here\u0026rsquo;s a straightforward exercise for you: duplicate all the target bones and rename them as ctrl_*, where * represents the relative name. Skip copying the mch bone, because mechanisms aren\u0026rsquo;t controls. After this, set up the parenting to mimic the target bone hierarchy.\nNow, here\u0026rsquo;s the trick I\u0026rsquo;ve been hinting at: do not duplicate tgt_body. Instead, we\u0026rsquo;ll make it a control (so you can add it to ctrl collection). This step is crucial to avoid rotation glitches.\nRemember to add them to collections afterwards Now, we need our target bones to follow controls, so let\u0026rsquo;s add copy transform from controls to targets. This time, we\u0026rsquo;re going to do it faster - by SHIFT clicking first ctrl, then tgt bone and using the same shortcut as with the deformation bone - SHIFT+CTRL+C.\nIf you cant click the bone, you can always select it in outliner Let\u0026rsquo;s brainstorm about our other controls - beginning with ctrl_cog and tgt_body. A standard cog (sometimes referred to as hips) is usually a big circle around \u0026ldquo;hips\u0026rdquo; area. We\u0026rsquo;ll roll with it, also creating a smaller circle for the rotation purposes. When you add a shape, keep in mind that you can tweak its dimensions by hitting the Edit button, allowing you to resize the controls.\nYou can notice, that I\u0026rsquo;ve forgotten to add tgt_body to the right collection before and it didn\u0026rsquo;t let me create shape because tgt was hidden When it comes to stretching controls, their design can vary from one rig to another. However, for our rig, let\u0026rsquo;s categorize them as auxiliary controls. This implies that we need to create a shape that conveys the purpose behind its function, enabling animators to grasp how to manipulate the controller as naturally as possible. Think of control design as a form of UX of rigging techniques - incorporating markers that, through form, shape, or color, subtly guide users on how to interact with our rigs. If you\u0026rsquo;re interested in delving deeper into the concept of markers in design, Donald Norman\u0026rsquo;s The Design of Everyday Things is a great resource.\nAs my choice for markers, I\u0026rsquo;ve settled on pyramids. Their pointy side naturally guides the eye towards the ball, creating an intuitive sense that translating the controller towards the inside will produce a certain effect, probably toward the center of the ball. Now that we\u0026rsquo;ve looked into my process, feel free to add them yourself. By the end, your setup should look similar to this:\nIf you select two bones, you can add the same shape at the same time! As you can observe, my pyamids are a bit smaller and shifter outwards. You can achieve this effect either by utilizing the Edit option or by accessing the menu that appears in the bottom-left corner. Experiment with these features to fine-tune the size and positioning to match your design!\nAfter gaining experience with enough rigs, you\u0026rsquo;ll likely notice that colors in rigging tend to follow similar patterns, regardless of the author. I\u0026rsquo;ve developed my own control scheme, which I\u0026rsquo;m excited to share with you:\nLeft side controls are RED Right side controls are BLUE Middle side controls are YELLOW Auxilary controls are GREEN To change the control colors, navigate to Bone\u0026gt;Viewport Display in Properties tab. I typically opt for a custom color theme, utilizing the adjacent button to copy the color scheme to other colors (with the source object being the LAST selected).\nGive it a shot by selecting ctrl_stretch-top, navigating to it\u0026rsquo;s Viewport Display tab and adding a custom color theme with a vibrant green shade. Once set, select the remaining auxiliary controls and hit the double arrow button to match these colors.\nBlender uses a specific setup where you give 3 colors - Regular / Select / Active Since you\u0026rsquo;re now adept at adding control colors, let\u0026rsquo;s bring this to a close by adding them into the remaining controllers. Your final result should resemble this:\nWe\u0026rsquo;ve almost done! 5. Clean up \u0026amp; final touches # Now that we\u0026rsquo;ve build everything, you might be tempted to dive straight into animation.\nHold on!\nRemember, I mentioned that a mess can be a real headache later, so let\u0026rsquo;s wrap up with some final cleanup.\nWe\u0026rsquo;ll start with Armature Tab - we can finally check off Names, In Front and Axes tab - animators don\u0026rsquo;t really need them and if they need to have controls in front, they\u0026rsquo;ll set them up.\nYour rig should look like this Before we conclude, let\u0026rsquo;s address one more crucial aspect: locking certain transforms. Althoguh I\u0026rsquo;m usually in favor of providing animators with flexibility (of not locking their transforms), there are instances where a bit of guidance can enhance their animation experience.\nLet\u0026rsquo;s begin with the stretch controllers. While animators can manipulate these with transform (location), rotation and scale are only going to make the controls spin/scale without any influence over the rig - to streamline usage, we can lock these transforms, allowing animators to control the squashing effortlessly by simply pressing G.\nThe last thing we should think about is locking up some transforms - I am generally against limiting animators choices, but there are some things we can do, to help animators in their work.\nYou can hold LMB and drag to lock more than one thing at a time After this, let\u0026rsquo;s consider the rotation control. We don\u0026rsquo;t really need the scale, so it should be locked. Rotation is the primary focus, so that should remain open. What about location? There are two schools of thought on this. Some prefer locking it out since the control isn\u0026rsquo;t meant for translation. However, as stated earlier, I believe it\u0026rsquo;s better to leave it open. Animators can discern if they\u0026rsquo;ve added a keyframe to the wrong controller and rectify it themselves. Moreover, they might need to detach the translation to two different bones, and this setup facilitates that. Keep in mind that leaving the location unlocked might affect some squash transforms (if you really try to break the setup) - ultimately the decision is yours.\nMoving onto the cog, as the main control for moving the mesh, both location and rotation should be open. However, for the scale, I suggest locking it to prevent potential bugs.\nFinally - the root control - certaintly, location and rotation should be unlocked. Regarding scale, with our setup of maintaining a consistent hierarchy, users can easily scale the root to achieve different sizes easily. Controls will scale proportionally, ensuring the rig functions seamlessly. However, scalability isn\u0026rsquo;t always straightforward in rigging and careful consideration is needed when designing controls.\n6. Closing Thoughts # Congratulations on successfully rigging your first ball! Now, you can embark on your animation journey, starting with bouncing ball exercises. Additionally, you\u0026rsquo;ve gained insights into planning controls and naming conventions, which will prove invaluable in your future endeavors.\nIf you\u0026rsquo;re as excited as I am, I won\u0026rsquo;t keep you any longer. After mastering the ball, the animation world is yours to explore!\nHappy animating!\nAnd if you choose to share you ball animation, tag me (@arahfx) - I\u0026rsquo;d love to see your creations!\n","date":"22 February 2024","permalink":"/adamblogstuff/posts/squashstretch_blender/","section":"Posts","summary":"A step by step guide to build your first ball rig in blender","title":"Squash \u0026 Stretch Ball in blender"},{"content":"","date":"22 February 2024","permalink":"/adamblogstuff/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"22 February 2024","permalink":"/adamblogstuff/","section":"Techanimatically","summary":"","title":"Techanimatically"},{"content":"","date":"21 February 2024","permalink":"/adamblogstuff/tags/theory/","section":"Tags","summary":"","title":"Theory"},{"content":"Our first rig - a squash \u0026amp; stretch ball # 0. Foreword # In this article you\u0026rsquo;ll learn:\nThe importance of ball exercises for learning animation Basic idea on what Ball Rig consist of Learn common slang for some controller types Understand what is happening in the code of \u0026ldquo;stretch\u0026rdquo; modifiers in popular programs 1. Why is ball important? # Whether you\u0026rsquo;re just starting your animation journey, study the craft, or you\u0026rsquo;re a seasoned animation veteran - the foundation of everything you know about animation starts with a ball.\nIf we take a cue at Richard William\u0026rsquo;s The Animator\u0026rsquo;s Survival Kit, the first chapter titled IT\u0026rsquo;S ALL IN THE TIMING AND THE SPACING - delves into how we use these two terms to understand the basics of any motion.\nI\u0026rsquo;ll never forget the image of this big Norwegian American sitting in the golden twilight, extending his long arms and spatula hands saying\u0026hellip; «The bouncing ball says it all»\n\u0026ndash;R. Williams \u0026ldquo;The Animators Survival Kit\u0026rdquo;\nThat\u0026rsquo;s why I want my first post to be dedicated to building a proper ball rig - a foundation upon one can explore basics of spacing, timing and squash \u0026amp; stretch principles. Additionally, we\u0026rsquo;ll peek under the hood of rigging mesh that can preserve it\u0026rsquo;s volume while being scaled.\nOf course, in 3D animation there are two main groups of users: Autodesk Maya and blender. I\u0026rsquo;ll try to explain the ideas in a software-agnostic manner. However, there will be chapters dedicated to one software, but I\u0026rsquo;m going to write every tutorial for both sofwares - ensuring noonoe feels left out.\nI\u0026rsquo;ll be using some scripts along the way, presented like this:\nExample - so you can install it yourself and follow along.\nFurthermore, I\u0026rsquo;ll include rigs created in the series - fully functional and suitable for use as foundational animation tutorials. They will be provided totally free of charge and licensed under GPL v3.0.\nIf you\u0026rsquo;re interested in delving into the technical aspects of animation, let\u0026rsquo;s get started!\n3. What is actually squash \u0026amp; stretch? # You\u0026rsquo;re probably familiar with the concept of squashing and stretching - it seems deceptively simple. When we squash a water balloon, the water inside pushes the sides, giving it a pancake-like appearance. Upon release, it springs back to its more natural shape, and if thrown - it stretches in the air before squashing upon impact.\nA balloon squashing on a face, courtesy of gifer.com Disney\u0026rsquo;s Nine Old Men identified squashing and stretching as one of the most crucial principles for creating visually appealing animation. It holds such significance that they designate dit as the the #1 principle in their 12 Principles of Animation. Understanding this principle is a cornerstone for today\u0026rsquo;s animators, whether they\u0026rsquo;re sketching frames or manipulating a complex humanoid body. Accounting for squash and stretch is essential to achieving the elusive illusion of life.\nThe mathematical explanation # Let\u0026rsquo;s start by eating the frog. In mathematical terms, we\u0026rsquo;ll consider a sphere with dimensions of x, y and z and a volume V1. We will then manipulate it by multiplying by n in one direction and by \\(\\frac{1}{\\sqrt{n}}\\) in the other directions. This manipulation aims to achieve a new volume V2 that emains equal to V1.\n\\(\\text{Volume} = x \\cdot y \\cdot z = n \\cdot y \\cdot \\left(\\frac{x}{\\sqrt{n}}\\right) \\cdot \\left(\\frac{z}{\\sqrt{n}}\\right)\\)\nWhere: x, y, z - our sphere transform values\nn - the amount of change along we add, in this case along Y axis\nRigging explanation # When it comes to rigging, achieving a volume preservation effect can be approached in various ways based on the intended use and desired outcome.\nThose of you who transition to animation from modelling, the first technique that may come to mind is the Lattice Deformer.\nLattice around the cube object in Object Mode - from blender official docs Lattice is a deformer present both in blender and Maya, commonly used for applying deformation. However, for our purposes where a deformation cage can be constrained and controlled, it might not be the most versatile method for creating mesh deformations. Despite encountering numerous YouTube tutorials utilizing such approach, I won\u0026rsquo;t be delving into this method in the upcoming ball rig tutorials.\nSquash deformer results - from Maya docs Second method, more aligned with the rigging tools themselves, involves using Stretch To Constraint (in blender)/ Squash Deformer (in Maya). These are off-the-shelf features that can significantly simplify construction of said mechanism in rigging. However, they might have limitations in more advanced setups.\nAs of version 4.0, blender hasn\u0026rsquo;t introduced rigging nodes yet, we\u0026rsquo;ll be utilizing Stretch To Constraint in the blender-specific tutorial. But how does it work under the hood?\nThe fundamental concept behind volume-preservating squash \u0026amp; stretch is joint scaling. When we stretch an object, it\u0026rsquo;s joint (or chain of joints) undergoes scaling. Of course when it squashes, the chain naturally scales too. This scaling can be applied uniformly along all axes - providing full-scaling of the rig or selectively along specific axes. To mimic the simultaneous change if onther axes, we can use the Volume ratio presented before.\nLet\u0026rsquo;s try this example.\nTo illustrate this, let\u0026rsquo;s assume we have an object whose transforms are (x, y, z).\nWe can stretch the bone by vector \\(\\vec{v}\\) = [0, 1, 0] resulting in new transform:\n(x, y+1, z)\nBy knowing the new value of y transform, we can calculate n.\nTo sell the effect of stretching, we need to scale the same object in other axes to achieve the same volume. To achieve that, we\u0026rsquo;ll use the formula I\u0026rsquo;ve written about before.\nWhen we scale object in y axis by n, we\u0026rsquo;ll multiply x and z scale by \\(\\frac{1}{\\sqrt{n}}\\) - to preserve the volume of the object.\nIn Maya\u0026rsquo;s Rigging Node Editor, it is possible to connect x, y and z direclty with multiplyDivide node, to multiply these channels accordingly. This method is going to achieve a good squash \u0026amp; stretch that is going to work on all type of bone chains - it\u0026rsquo;s extremly useful for humanoid skeleton rigs with cartoon features!\nSquash \u0026amp; Stretch in video games # Squash \u0026amp; Stretch isn\u0026rsquo;t something you\u0026rsquo;ll often encounter in videogames, at least now by default.\nUnreal Engine, for instance, doesn\u0026rsquo;t export scale of deformation bones at all! This might prompt one simple question - why bother?. The reason behind this decision is quite substantial. Achieving a good looking, volume-preserving squash \u0026amp; stretch of Skeletal Mesh entails calculating skinning deformations every frame, making it one of the most resource-hungry tasks for player\u0026rsquo;s CPU. While enabling bone scaling during mesh inport is an option to preserve these effects, it\u0026rsquo;s typically not the default setting due to performance problems. In many cases, this decision alligns with overall optimization strategies - it\u0026rsquo;s going to be used only when the game really depends on it.\nGiven the heavy optimization implications, there\u0026rsquo;are other techniques that might mimic the feeling of squashing and stretching in video games. These often include translations of the skeleton, mostly adjustments to arms and legs. Let\u0026rsquo;s consider jumping - by translating parts of skeleton one can achieve a stronger, more dynamic pose, for example by leaving the legs for a few frames on the ground longer only to squash them together (to their original position) nearing the apex of the jump loop. Such technique of translation can be observed in World of Warcraft\u0026rsquo;s Pandaren Jump.\nPandaren jump loop probably my favourite WoW animation These are just a few examples of the different tricks animators employ to create the illusion of life, even though it may not involve the real calculated volume-preserving squash \u0026amp; stretch. After all, the ultimate goal is to sell the viewer the best looking, lively performance withing the constraints of game performance.\n3. How does a ball rig work? # Mesh # For this example I\u0026rsquo;ll be using a mesh with a checker texture, that you can download:\nFor blender here For Maya here [tutorial W.I.P] Skeleton # In it\u0026rsquo;s simplest form, a ball skeleton consists of just one bone, where joints (Maya) / head and tail of the bone (blender) are touching the sphere\u0026rsquo;s base and end. These hold whole skinning information, making it an ideal object to use automatic skinning options for.\nControls # Considering what animator might need to control in a ball rig, we might think of a few cases.\nFor blender I\u0026rsquo;m going to use Bone Widget to create control shapes.\nFor Maya, I\u0026rsquo;m are going to use IDR ControllerTools to do the same. Every rig, at the top of it\u0026rsquo;s hierarchy has to have a root. It\u0026rsquo;s purpose is to hold information about the default space of the rig. It\u0026rsquo;s often represented by a variation of circles with arrows on the ground.\nPossible shapes of root bones using Bone Widget The next in hierarchy, overarching rest of the controllers is a bone called cog - or sometimes stylized as c.o.g (abbreviation for center of gravity). These might get a lot different shapes depending of the center of gravity shape. The most popular ones are circles and saddles, for the purpose of ball rig, we\u0026rsquo;ll use a big circle.\nA Saddle-like shape for cog from Bone Widget The hierarchy of the rest of controllers might differ depending on circumstances. In case of our ball rig, we\u0026rsquo;ll have a few controllers following a cog. First of them will be a rotor - our second level controller. In this case rotor will be working the same as the cog - it\u0026rsquo;ll let animators translate or rotate a mesh (unless we lock it) and it\u0026rsquo;s main purpose will be to split rotation and translation to avoid clutter in the timeline and graph editor. We\u0026rsquo;ll use a smaller circle for this controller.\nThe last type of controllers for this rig is going to be an auxilary controller that will let animator control the squash and stretch of the mesh - preferably from the top and botton. There is no one way to imagine general shape of these controllers - their shape are going to refer to their function. In our case it\u0026rsquo;s going to be a control that might move up and down, so something with a pointy end might be a good idea. We\u0026rsquo;ll talk more about specific shapes in the next chapters.\n4. Closing Thoughts # We explored the concept of squash and stretch, delving into its significance and mechanics. Our discussion included its importance in animation and various ways to mimic it when necessary. Additionally, we laid down the foundational theory for building a functional ball rig.\nArmed with this knowledge, the upcoming articles will take a hands-on approach, applying the knowledge to create a working ball rig that you\u0026rsquo;ll be able to animate yourself. If you have any further questions of need assistance, dont hesitate to ask.\nHappy rigging!\n","date":"21 February 2024","permalink":"/adamblogstuff/posts/squashstretch/","section":"Posts","summary":"Overlook of squash \u0026amp; stretch mechanism building with with different rigging approaches","title":"Theory behind building a squash \u0026 stretch rig"},{"content":"Hey! I\u0026rsquo;m Adam. # I am an Animator / Rigger, based in Wrocław, Poland.\nCurrently, I am working at Far From Home where I am animating and rigging Forever Skies!\nWelcome to my blog, where I explore the art of rigging, gameplay animation and *technical animation. This blog serves as a blend of insights into rigging techniques, animation principles, scripting, and their application in the dynamic world of video games.\nBeyond discussion, my goal is to offer valuable tutorials and resources to aid you on your (and mine) journey through everything there is related to animation for video games. I\u0026rsquo;ll also try sprinkle in some thought-provoking book reviews and reflections on the broader animation industry. I believe in the power of animation as the ultimate storytelling medium in the entertainment industry. I\u0026rsquo;m excited to share my experiences and perspectives on every facet of this captivating medium.\nMy unique background encompasses both art (Graphic Design) and engineering (Computer Science), a blend that has propelled me into the specialized field of technical animation. Outside of my professional pursuits, I\u0026rsquo;m a reportage photographer, crafting digital photography books, a cinematography freak and an avid player of both digital and analog RPGs. I hope you\u0026rsquo;ll enjoy your time here!\nIf you have any questions or just want to chat - I am open to DMs at both my X and LinkedIn accounts that you can find on top :)\n","date":"11 February 2024","permalink":"/adamblogstuff/about/","section":"Techanimatically","summary":"T","title":"About"},{"content":"","date":"1 January 0001","permalink":"/adamblogstuff/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/adamblogstuff/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/adamblogstuff/portfolio/","section":"Techanimatically","summary":"","title":"My Portfolio"},{"content":"Games I\u0026rsquo;ve been a part of # Forever Skies (PC, PS5) # Forever Skies - Animation \u0026amp; Rigging Forever Skies is the first project I am working on as an animator/rigger. I\u0026rsquo;ve been working mostly on third and first person animations, rigging and skinning of humanoids, non-humanoids and devices for Unreal Engine 4 and I\u0026rsquo;ve been helping in implementation of the animation system within the project.\nMy own projects # Rigs for Animation Students in blender \u0026amp; Maya # I\u0026rsquo;ve been working on bringing basic animation rigs like balls, pendulums, tails and walker animation rigs to help students with both learning how to rig these. On many Polish gamedev networking events I\u0026rsquo;ve noticed a lack of good quality basic rigs for blender and that\u0026rsquo;s why I wanted to give back to the community by making something that might work software independently (of course it\u0026rsquo;s not possible by doing it once, so I just rig \u0026amp; create tutorials for both softwares).\n","date":"1 January 0001","permalink":"/adamblogstuff/projects/","section":"Techanimatically","summary":"Games I\u0026rsquo;ve been a part of # Forever Skies (PC, PS5) # Forever Skies - Animation \u0026amp; Rigging Forever Skies is the first project I am working on as an animator/rigger.","title":"Projects"}]